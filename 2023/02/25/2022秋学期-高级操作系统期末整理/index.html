<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">2022秋学期-高级操作系统期末整理 | owuiviuwo&#39;s blog!</title>
  
    <link rel="shortcut icon" href="/images/hamster.png">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  
  <link rel="stylesheet" type="text/css" href="/css/matery.css">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "owuiviuwo";
  mashiro_option.author_name = "owuiviuwo";
  mashiro_option.site_url = "https://owuiviuwo.github.io/";
  mashiro_option.v_appId = "Bca3aRLRAJx2I6PNPDTapKBT-MdYXbMMI";
  mashiro_option.v_appKey = "o1JOvsCvLL7SkH0kH1SeRXKK";
  mashiro_option.mathjax = "1";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover0.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover1.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover2.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover3.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover4.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover5.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover6.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover7.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover8.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover9.webp,https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/cover/cover10.webp".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>

<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-grid">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <!--<a href="https://owuiviuwo.github.io/">-->
		<a href="/random.html">
          <img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>Learn and Live</p>
        <div class="top-social_v2">
		<!-- 这里去掉了框架原来的显示前一张背景图功能 在themes\Sakura\layout\_partial\headertop.ejs下 -->
		<!--
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
		  -->
          
            
              
                <li>
                  <a href="http://github.com/owuiviuwo" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://www.cnblogs.com/owuiviuwo" target="_blank" class="social-github" title="cnblogs">
                    <img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/social/cnblogs.svg">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://www.zhihu.com/people/owuiviuwo" target="_blank" class="social-github" title="zhihu">
                    <img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/social/zhihu.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="mailto:owuiviuwo@163.com" target="_blank" class="social-github" title="email">
                    <img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/social/email.svg">
                  </a>
                </li>
              
            
          
		  <!-- 这里去掉了框架原来的显示后一张背景图功能 在themes\Sakura\layout\_partial\headertop.ejs下 -->
		  <!--
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
		  -->
        </div>
      </div>
    </div>
  </figure>
  <!-- 这里去掉了框架原来的视频播放部分 在themes\Sakura\layout\_partial\headertop.ejs下 -->
  <!--
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  -->
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono"></span>
            <span class="shironeko">owuiviuwo</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/生活/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/资源/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/转载/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                      <li>
                        <a href="/random.html">
                          <i class="fa fa-random" aria-hidden="true"></i>
                          随机
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    数据
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/statistics/">
                          <i class="fa fa-line-chart" aria-hidden="true"></i>
                          统计
                        </a>
                      </li>
                    
                      <li>
                        <a href="/postcategory/">
                          <i class="fa fa-list-ul faa-vertical" aria-hidden="true"></i>
                          分类
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/">
                          <i class="fa fa-tags" aria-hidden="true"></i>
                          标签
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/shuoshuo/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-clock-o" aria-hidden="true"></i>
                    说说
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    友人帐
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/donate/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
                    赞赏
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    其他
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                      <li>
                        <a href="/theme-sakura/">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                      <li>
                        <a href="/lab/">
                          <i class="fa fa-cogs" aria-hidden="true"></i>
                          Lab
                        </a>
                      </li>
                    
                      <li>
                        <a href="/atom.xml">
                          <i class="fa fa-rss faa-pulse" aria-hidden="true"></i>
                          RSS
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/26/151d61752a11157cec91f00c2a37e943-20230226104700259-a12130.jpeg);" src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/26/151d61752a11157cec91f00c2a37e943-20230226104700259-a12130.jpeg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      2022秋学期-高级操作系统期末整理</h1>
      <p class="entry-census">
        <span>
          <a href="https://owuiviuwo.github.io/">
            <img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="https://owuiviuwo.github.io/">owuiviuwo</a>
        </span>
        <span class="bull">
        ·</span>
        2023-2-25<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">

       <div id="outDateInfo">
	   <!-- 过时信息提示，来源于 https://cndrew.cn/2020/04/04/date/ -->
	   <style>
		   .tip.share {
				border-left-color: rgb(238, 5, 5);
				background: #fff;
			}
			.tip {
				display:block;
				background: #fff;
				padding: 8px 20px;
				position: relative;
				margin: 0 0 20px;
			 
				font-family: Georgia, serif;
				font-size: 16px;
				line-height: 1.2;
				color: #666;
				text-align: justify;
				border-left: 5px solid      #3CB371;
			 
				/*盒子阴影 - (选项)*/
				-moz-box-shadow: 2px 2px 15px #ccc;
				-webkit-box-shadow: 2px 2px 15px #ccc;
				box-shadow: 2px 2px 15px #ccc;
			}
			.tip.share:before {
				background: #ddd;
				content: "🐷";
			}
			.tip:before {
				background: #38a3fd;
				border-radius: 50%;
				color: #fff;
				content: "i";
				font-family: Dosis,"Source Sans Pro","Helvetica Neue",Arial,sans-serif;
				font-size: 16px;
				height: 21px;
				line-height: 21px;
				margin-left: -32px;
				margin-top: 8px;
				position: absolute;
				text-align: center;
				width: 21px;
			}
	   </style>
	   	  <div id="point"></div>
			 <script>
			  function intervalTime(startTime,endTime){
				  var date1 = new Date(startTime);
				  var date2 = new Date(endTime);  
				  var date3 = date2.getTime() - date1.getTime(); 
				  var days = Math.floor(date3 / (24 * 3600 * 1000));
				  return days;
			  }
			  function format(Date){
				var Y = Date.getFullYear();
				var M = Date.getMonth() + 1;
				  M = M < 10 ? '0' + M : M;
				var D = Date.getDate();
				  D = D < 10 ? '0' + D : D;
				var H = Date.getHours();
				  H = H < 10 ? '0' + H : H;
				var Mi = Date.getMinutes();
				  Mi = Mi < 10 ? '0' + Mi : Mi;
				var S = Date.getSeconds();
				  S = S < 10 ? '0' + S : S;
				  return Y + '-' + M + '-' + D + ' ' + H + ':' + Mi + ':' + S;
			  }
			  // var pdate = new Date("1677312453000");
			  var pdate = new Date(1677312453000);
			  console.log("pdate="+pdate);
			  console.log("1677312453000");
			  //var update = new Date("1677939223411");
			  var update = new Date(1677939223411);
			  console.log("1677939223411");
			  console.log("update="+update);
			  var now = new Date();
			  console.log("now="+now);
			  now=format(now);
			  pdate=format(pdate);
			  update=format(update);
			  var days=intervalTime(pdate,now),udays=intervalTime(update,now);
			  var mid=parseInt(days,10);
			  var mi=parseInt("30",10);
			  if(mid > mi){
				document.getElementById("point").innerHTML="<div class=\"tip share\">请注意，本文编写于"+days+"天前，最后修改于"+udays+"天前，其中某些信息可能已经过时。<img src=\"https://cdn.jsdelivr.net/gh/drew233/cdn/kawayi.webp\"><\img> </div>";
			  }
			</script>
	   </div>

	  
	  <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h1 id="2022秋学期-高级操作系统期末整理"><a href="#2022秋学期-高级操作系统期末整理" class="headerlink" title="2022秋学期 高级操作系统期末整理"></a>2022秋学期 高级操作系统期末整理</h1><h2 id="C0-引言"><a href="#C0-引言" class="headerlink" title="C0 引言"></a>C0 引言</h2><p>本文内容来自于对高级操作系统课程资料的整理；</p>
<p>本文所涉及的课程指东北某沿海高校，计算机学院硕士生必修课“高级操作系统”，课程资料包括课程PPT、教材《分布式系统原理与范型 第二版》<sup><a href="#fn_1" id="reffn_1">1</a></sup>、《Distributed Systems Principles and Paradigms 2nd edition》<sup><a href="#fn_2" id="reffn_2">2</a></sup>，以及网络资料。</p>
<blockquote id="fn_1">
<sup>1</sup>. 《分布式系统原理与范型 第二版》 作者: （美）特尼博姆 出版社: 清华大学出版社 原作名: Distributed Systems: Principles and Paradigms 译者: 辛春生 :出版年: 2008-6-1 页数: 490 ISBN: 978730217279<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 《Distributed Systems Principles and Paradigms 2nd edition》:作者: Tanenbaum, Andrew S. / Steen, Maarten van 出版社: Pearson 出版年: 2001-9-1 页数: 803 ISBN: 9780131217867<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<h2 id="C1-分布式系统概述"><a href="#C1-分布式系统概述" class="headerlink" title="C1 分布式系统概述"></a>C1 分布式系统概述</h2><h3 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h3><p>定义：分布式系统是若干独立计算机的集合，它们对于用户来说就像一个系统</p>
<h3 id="分布式系统中透明性的种类"><a href="#分布式系统中透明性的种类" class="headerlink" title="分布式系统中透明性的种类"></a>分布式系统中透明性的种类</h3><div class="table-container">
<table>
<thead>
<tr>
<th>透明性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问</td>
<td>隐藏数据表示形式以及访问方式的不同</td>
</tr>
<tr>
<td>位置</td>
<td>隐藏数据所在的位置</td>
</tr>
<tr>
<td>迁移</td>
<td>隐藏资源是否已移动到另一个位置</td>
</tr>
<tr>
<td>重定位</td>
<td>隐藏资源是否在使用中已移动到另一个位置</td>
</tr>
<tr>
<td>复制</td>
<td>隐藏资源是否已被复制</td>
</tr>
<tr>
<td>并发</td>
<td>隐藏资源是否由若干相互竞争的用户共享</td>
</tr>
<tr>
<td>故障</td>
<td>隐藏资源的故障和恢复</td>
</tr>
<tr>
<td>持久性</td>
<td>隐藏资源（软件）位于内存里或磁盘上</td>
</tr>
</tbody>
</table>
</div>
<p>透明度：透明性受到的限制 必须将透明性与其他因素（如性能）结合起来考虑（如复制透明性中的复制更新）</p>
<h3 id="分布式系统中的扩展技术有哪些"><a href="#分布式系统中的扩展技术有哪些" class="headerlink" title="分布式系统中的扩展技术有哪些"></a>分布式系统中的扩展技术有哪些</h3><ol>
<li><p>隐藏通信等待时间</p>
<ul>
<li><p>异步通信</p>
</li>
<li><p>减少通信量</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/54711a6b4678851cf3f446a5899bcf05-20230225161018593-170c62.png" alt="image-20230214154410735"><br>a 由服务器检查表单； b 由客户端检查表单</p>
</li>
</ul>
</li>
<li><p>分布技术：分割组件，分散到系统中，如DNS和WWW</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/2c0f528c3c920d3816ee2b1c512c6bab-20230225161030654-d9fa4a.png" alt="image-20230214154453523"></p>
<p>将DNS名字空间划分为区的例子</p>
</li>
<li><p>复制技术：多拷贝</p>
<p>复制：增加可用性，有助于负载均衡</p>
<p>缓存：在访问资源的客户周围制作资源备份</p>
<p>一致性问题</p>
</li>
</ol>
<h2 id="C2-体系结构"><a href="#C2-体系结构" class="headerlink" title="C2 体系结构"></a>C2 体系结构</h2><h3 id="客户端-服务器模型"><a href="#客户端-服务器模型" class="headerlink" title="客户端-服务器模型"></a>客户端-服务器模型</h3><h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><ul>
<li>服务器：实现某个特定服务的进程</li>
<li>客户：向服务器请求服务的进程</li>
<li>客户端-服务器之间的一般交互：请求/回复</li>
<li>无连接的协议：高效，受传输故障的影响，适合局域网</li>
<li>基于连接的协议：性能相对较低，适合广域网</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/717b2429962dbde5eab1c4aeb05d52be-20230225161036862-1b20d2.png" alt="image-20230204223917125"></p>
<p>客户服务器应用程序通常组织为三个层次：</p>
<ul>
<li>用户界面层：用户交互所需的一切</li>
<li>处理层：应用程序核心功能</li>
<li>数据层：操作数据或文件系统，保持一致性</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/574328afee7d76f0c778360773f5d3eb-20230225161123826-272ecb.png" alt="image-20230204223932539"></p>
<p>客户端-服务器模型可能具有多层体系结构，可能的组织结构如下图<code>a-e</code>所示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/65a8cc7321ffb2ad9c74f9d269c366a7-20230225161132844-d2518a.png" alt="image-20230204223940536"></p>
<p>服务器可充当客户端角色，应用服务器向数据库服务器发出了请求，这里应用服务器作为客户端，如下图例中所示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/cc1a4dcbd658db58c173b1241ef558d2-20230225161138792-cc8f17.png" alt="image-20230204223946064"></p>
<h4 id="非集中式体系结构"><a href="#非集中式体系结构" class="headerlink" title="* 非集中式体系结构"></a>* 非集中式体系结构</h4><ul>
<li>垂直分布式：按照逻辑把不同的组件放在不同的机器上</li>
<li>水平分布式：客户或服务按照在物理上被分割成逻辑上相同的几部分，如：点对点系统</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/457ccc2f1928462cd7159b2ec12a6792-20230225161143605-f88f41.png" alt="image-20230204224046312"></p>
<h4 id="混合体系结构-协作分布式系统"><a href="#混合体系结构-协作分布式系统" class="headerlink" title="* 混合体系结构-协作分布式系统"></a>* 混合体系结构-协作分布式系统</h4><p>协作分布式系统：以C/S方式启动，一旦节点加入，则以完全非集中式协作，如：BitTorrent（BT）</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/e981cd09ad12e7de05df03019b963469-20230225161151399-f15f22.png" alt="image-20230204224257555"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/1a3c4bd201c53ff957bb4bac8ce4f3c5-20230225161158933-0ea14e.png" alt="image-20230204224333276"></p>
<p>BT 下载网络有三个关键静态组件：</p>
<ul>
<li>跟踪器（Tracker）：Tracker跟踪器是一个中央服务器，它主要跟踪系统中所有的参与节点，收集和统计这些节点的状态，帮助参与节点间互相发现并进行文件块的交换</li>
<li>种子节点（Seed）：Seed种子节点是指拥有完整文件的节点，提供上载服务</li>
<li>下载节点（Downloader）：相对于Seed的节点称为下载节点，一个下载节点完成下载后，可以成为种子节点。</li>
</ul>
<p>BT的体系结构如下图所示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/44405550bfb02e7d5adfa0f35aa7b0ea-20230225161206279-9d0269.png" alt="image-20230204224458166"></p>
<p>BT的动态流程为：</p>
<ul>
<li>第一个用户通过BT工具制作要共享的Torrent文件（Torrent文件包含共享文件的下载信息）并发布此Torrent到WWW（网络）中</li>
<li>其他用户从WEB服务器上下载此Torrent文件并通过节点跟踪器协议（如TrackerHTTP）去访问Tracker跟踪器。参与到此Torrent网络中</li>
<li>Tracker跟踪器接收到一个新加入节点的下载请求后，随机选择部分此Torrent网络中的节点，发送给新加入者作为邻居节点，并记录此新节点</li>
<li>新加入节点通过一定的算法同邻居节点连接进行文件的下载和上载，直到文件下载完成。这一过程会根据一定的策略重复。如果继续上载，Tracker服务器将此节点看作种子节点</li>
<li>所有参与的节点将周期地报告自己的状态和进程给Tracker跟踪器</li>
</ul>
<p>BT涉及的关键技术有：</p>
<ul>
<li>BT文件发布系统采用争锋相对（Tit_for_Tat）的方法发来达到帕累托（Pareto）有效，与当前其他的P2P技术相比，它达到了更高层次的鲁棒性和资源利用</li>
<li>帕累托最优：指资源配置已达到这样一种境地，即任何重新改编资源配置的方式，都不可能使一部分人在没有其他人受损的情况下受益</li>
<li>最少优先原则：对一个下载者来说，在选择下一个被下载的片段时，通常选择的是它的Peers（指邻居下载者）所拥有的最少的那个片段，也就是所谓的”最少优先“</li>
</ul>
<h2 id="C3-分布式进程管理"><a href="#C3-分布式进程管理" class="headerlink" title="C3 分布式进程管理"></a>C3 分布式进程管理</h2><h3 id="进程和线程的比较"><a href="#进程和线程的比较" class="headerlink" title="进程和线程的比较"></a>进程和线程的比较</h3><ul>
<li>地址空间和其他资源（如打开文件）：进程间相互独立，同一进程的各线程间共享该进程地址空间和其他资源；某进程内的线程在其他进程不可见</li>
<li>通信：进程间通信通过IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信；需要进程同步和互斥手段的辅助，以保证数据的一致性</li>
<li>调度：线程上下文切换比进程上下文切换要快得多</li>
<li>线程是CPU调度单位；进程只作为其他资源分配单位</li>
<li>结论：多线程能提高性能；线程不像进程那样彼此隔离，并受到系统自动提供的保护，因此多线程应用程序开发需要付出更多努力</li>
</ul>
<h4 id="相关的资料"><a href="#相关的资料" class="headerlink" title="* 相关的资料"></a>* 相关的资料</h4><ul>
<li>进程的定义：执行中的程序，进程控制块（PCB）；包含的状态如下：</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/07177760dd704f1d9eaff4ad554a9704-20230225161213543-e8f366.png" alt="image-20230204225509846"></p>
<ul>
<li><p>线程：CPU调度单位；进程只作为其他资源分配单位</p>
<ul>
<li>未引入线程前的进程是：资源分配单位（存储器、文件）和CPU调度（分配）的单位</li>
<li>线程只拥有必不可少的资源，如：线程状态、寄存器上下文和栈</li>
<li>线程同样具有就绪、阻塞和执行三种基本状态</li>
<li>进程的终止将导致它包含的所有线程的终止</li>
</ul>
</li>
<li><p>线程的优点：减少并发执行的时间和空间开销（线程的创建、退出和调度），因此容许在系统中建立更多的线程来提高并发程度</p>
<ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同进程内的线程切换时间比进程短</li>
<li>由于同进程内线程共享内存和文件资源，可直接进行不通过内核的通信</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/037ad354d2de66e72b27d28e314369dd-20230225161221889-82faa9.png" alt="image-20230204230251863"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/55168c11262aa91d3910318ed41f87fd-20230225161230372-357ec9.png" alt="image-20230204230308694"></p>
</li>
</ul>
<p>进程创建的时间</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/4fab7ec8542584c1d54a0d910b784497-20230225161236862-c7a40a.png" alt="image-20230204230339442"></p>
<p>线程创建的时间</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/f29f370035b4db40ef915fe7ebd6fccf-20230225161241785-d9741f.png" alt="image-20230204230351764"></p>
<h3 id="多线程服务器的优点"><a href="#多线程服务器的优点" class="headerlink" title="多线程服务器的优点"></a>多线程服务器的优点</h3><ul>
<li>在某一线程阻塞时，其他线程可以继续工作</li>
<li>利用多处理器，并行工作</li>
<li>缩短IPC通信的时间</li>
<li>出于软件工程的考虑：例如 字处理程序（用户输入、拼写检查、语法检查、文档布局）</li>
</ul>
<blockquote>
<p>多线程技术不仅能够显著简化服务器代码，还能够使得应用并行技术来开发高性能的服务器变得更加容易，即使在单处理器系统上也是如此。多线程能够保留顺序处理的思路，使用阻塞性系统的系统调用，仍然能到达并行处理的目的。使用阻塞系统调用使编程更容易，并行处理能提高系统的性能。</p>
</blockquote>
<ul>
<li>简化服务器代码</li>
<li>提高并行性</li>
<li>提高服务器性能</li>
<li>保留顺序处理思路</li>
<li>使用阻塞系统调用使得编程更容易</li>
</ul>
<h3 id="代码迁移的动机有哪些"><a href="#代码迁移的动机有哪些" class="headerlink" title="代码迁移的动机有哪些"></a>代码迁移的动机有哪些</h3><p>代码迁移的定义：将程序或执行中的程序传递到其他计算机</p>
<p>动机：</p>
<ul>
<li>实现负载均衡：将进程从负载重的系统迁移到负载轻的系统，从而改善整体性能</li>
<li>改善通信性能：交互密集的进程可迁移到同一个节点以减少通信开销；当进程要处理的数据量较大时，最好将进程迁移到数据所在的节点</li>
<li>可用性：需要长期运行的进程可能因为当前运行机器要关闭而需要迁移</li>
<li>使用特殊功能：可以充分利用特定节点上独有的硬件或软件功能</li>
</ul>
<h3 id="迁移与本地资源"><a href="#迁移与本地资源" class="headerlink" title="* 迁移与本地资源"></a>* 迁移与本地资源</h3><p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/50f532ff34d2e479eacda71ad5e82239-20230225161249833-826075.png" alt="image-20230204232028094"></p>
<h3 id="进程对资源的绑定类型有哪些"><a href="#进程对资源的绑定类型有哪些" class="headerlink" title="进程对资源的绑定类型有哪些"></a>进程对资源的绑定类型有哪些</h3><p>按标识符（URL）、按值和按类型</p>
<h3 id="资源对机器的绑定类型有哪些"><a href="#资源对机器的绑定类型有哪些" class="headerlink" title="资源对机器的绑定类型有哪些"></a>资源对机器的绑定类型有哪些</h3><p>未连接（数据文件）、附着连接（数据库）和紧固连接（本地设备）</p>
<h2 id="C4-分布式系统通信"><a href="#C4-分布式系统通信" class="headerlink" title="C4 分布式系统通信"></a>C4 分布式系统通信</h2><h3 id="什么是远程过程调用？远程过程调用的步骤"><a href="#什么是远程过程调用？远程过程调用的步骤" class="headerlink" title="什么是远程过程调用？远程过程调用的步骤"></a>什么是远程过程调用？远程过程调用的步骤</h3><p>远程过程调用（Remote Procedure Call， RPC）是分布式系统通信处理的事实标准，实现消息传输的透明性</p>
<blockquote>
<p>远程过程调用(Remote Procedure Call)RPC 是指本地程序调用位于其他机器上的进程，调用方通过消息的形式把参数传递到被调用方的进程，然后等待被调用方执行完后用消息的方式把结果传回调用方。 </p>
<p>远程过程调用：当机器A上的进程调用B上的进程时，A上的调用进程被挂起，而B上的被调用进程开始执行。调用方可以通过使用参数将信息传送给被调用方，然后可以通过传回的结果得到信息。编程人员看不到任何消息传递过程。这种方法称为远程过程调用。</p>
</blockquote>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>客户过程以正常的方式调用客户存根</li>
<li>客户存根生成一个消息，然后调用本地操作系统</li>
<li>客户端操作系统将消息发送给远程操作系统</li>
<li>远程操作系统将消息交给服务器存根</li>
<li>服务器存根将参数提取出来，然后调用服务器</li>
<li>服务器执行要求的操作，操作完成后将结果返回给服务器存根</li>
<li>服务器存根将结果打包成一个消息，然后调用本地操作系统</li>
<li>服务器操作系统将含有结果的消息发送给客户端操作系统</li>
<li>客户端操作系统将消息交给客户存根</li>
<li>客户存根将结果从消息中提取出来，返回给调用它的客户过程</li>
</ol>
<h4 id="相关的资料-1"><a href="#相关的资料-1" class="headerlink" title="* 相关的资料"></a>* 相关的资料</h4><p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/4ee6376c9c745781bce0fec675cd9509-20230225161507078-8756d4.png" alt="image-20230205154647998"></p>
<ul>
<li>常规过程调用</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/4e68e94f9893144083fab9ec89ba7d45-20230225161257588-b6d08d.png" alt="image-20230205153743671"></p>
<ul>
<li>客户存根和服务器存根</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/393034f6b00d406d617138280a8e190a-20230225161310805-a1d2a3.png" alt="image-20230205153817350"></p>
<ul>
<li>参数传递</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/3f2e812bb3d77024b6e96d83e92cbe89-20230225161326460-14fa4d.png" alt="image-20230205154449555"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/e54a8b8248533afedb02e13b630494b2-20230225161345672-770204.png" alt="image-20230205154500325"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/2fe06acb00bcd6d94aa9dea11a2da888-20230225161358157-3e721d.png" alt="image-20230205154510873"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/255c95bfa01f354468dbcc778b63377f-20230225161425092-6a2515.png" alt="image-20230205154525854"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/d90b47d44969b0b1df0c31d6f0325706-20230225161449088-620a46.png" alt="image-20230205154535259"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/2538feb1d6640c420b3149932617f74f-20230225161458609-6c73a5.png" alt="image-20230205154542714"></p>
<h3 id="消息持久通信和暂时通信的区别？"><a href="#消息持久通信和暂时通信的区别？" class="headerlink" title="消息持久通信和暂时通信的区别？"></a>消息持久通信和暂时通信的区别？</h3><ul>
<li>持久通信：通信双方不必保持运行</li>
<li>暂时通信：通信系统只在发送者和接收者运行时存储消息</li>
</ul>
<p>驿马快递时代使用的就是持久通信</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/df4617fe46d1c1efa6c508d0e0b4bbab-20230225161514533-86003e.png" alt="image-20230205161033546"></p>
<h3 id="消息同步通信和异步通信的区别？"><a href="#消息同步通信和异步通信的区别？" class="headerlink" title="消息同步通信和异步通信的区别？"></a>消息同步通信和异步通信的区别？</h3><p>下图中：</p>
<ul>
<li>a）持久异步通信：提交消息后立即执行其他程序，如电子邮件</li>
<li>b）持久同步通信：提交消息后会被阻塞，直到消息已到达并存储在接收主机</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/3da4deb013aca795716b65e6b58629c2-20230225162419708-4833cb.png" alt="image-20230205161835070"></p>
<h3 id="能够判断消息通信的类型"><a href="#能够判断消息通信的类型" class="headerlink" title="能够判断消息通信的类型"></a>能够判断消息通信的类型</h3><p>下图中：</p>
<ul>
<li>a）持久异步通信</li>
<li>b）持久同步通信</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/3da4deb013aca795716b65e6b58629c2-20230225162435669-ebb994.png" alt="image-20230205161835070"></p>
<p>下图中：</p>
<ul>
<li>c）暂时异步通信</li>
<li>d）基于接收的暂时同步通信</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/729e6118552aa1271567d7a8c89c1ad7-20230225162516743-96c961.png" alt="image-20230205162528274"></p>
<p>下图中：</p>
<ul>
<li>e）基于交付的暂时同步通信</li>
<li>f）基于响应的暂时同步通信</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/2b59968009d31069d32750a466f77b8a-20230225162521830-2b8c2f.png" alt="image-20230205162658740"></p>
<h3 id="多播通信：反熵和Gossiping"><a href="#多播通信：反熵和Gossiping" class="headerlink" title="多播通信：反熵和Gossiping"></a>多播通信：反熵和Gossiping</h3><h4 id="基于gossiping的数据通信"><a href="#基于gossiping的数据通信" class="headerlink" title="基于gossiping的数据通信"></a>基于gossiping的数据通信</h4><ul>
<li>Epidemic协议使用本地信息在大型节点集中快速地传播信息</li>
<li>提供最终一致性：保证所有的副本最终是一致的</li>
<li>一个服务器可以是：<ul>
<li>传染性的：持有愿意向其他服务器散布的更新</li>
<li>易感的：尚未更新的服务器</li>
<li>隔离的：已更新的服务器如果不愿意或不能扩散其更新</li>
</ul>
</li>
<li>反熵传播模型：服务器P周期的随机选取一台服务器Q交换更新，方式包括：<ul>
<li>P只把自己的更新推入Q：较差的选择？</li>
<li>P只从Q拉出新的更新</li>
<li>P和Q互相发送更新</li>
<li>可以证明：如果初始只有一台服务器具有传染性，无论采用哪种形式，更新最终将被传播到所有服务器上；$O(log(N))$，N为系统节点数</li>
</ul>
</li>
</ul>
<h4 id="Gossiping模型"><a href="#Gossiping模型" class="headerlink" title="Gossiping模型"></a>Gossiping模型</h4><ul>
<li>思想：<ul>
<li>如果服务器P刚刚因为数据项x而被更新，那么它联系任意一个其他服务器Q，并试图将更新推入Q</li>
<li>如果Q已经被其他服务器更新了，P可能会失去继续扩散的兴趣，变成隔离的（这种可能性是1/k）</li>
</ul>
</li>
<li>快速传播更新的方法</li>
<li>但不能保证所有的服务器都被更新了</li>
<li>$s=e^{-(k+1)(1-s)}$,$k=3$时，s小于2%；$k=4$时，s小于0.7%</li>
<li>可以将gossiping和反熵模型结合</li>
</ul>
<h2 id="C5-命名系统"><a href="#C5-命名系统" class="headerlink" title="C5 命名系统"></a>C5 命名系统</h2><h3 id="描述实体定位的方法有哪些？（名称、标识符和地址）"><a href="#描述实体定位的方法有哪些？（名称、标识符和地址）" class="headerlink" title="描述实体定位的方法有哪些？（名称、标识符和地址）"></a>描述实体定位的方法有哪些？（名称、标识符和地址）</h3><ul>
<li>名称：有位或字符串组成的串，用来指向一个实体</li>
<li>一个实体的<strong><em>访问点</em></strong>的地址称为该实体的<strong><em>地址</em></strong>：特定的服务器的地址：IP地址+端口</li>
<li>标识符：具有以下属性的名称：<ul>
<li>一个标识符最多指向一个实体</li>
<li>每个实体最多由一个标识符指向</li>
<li>一个标识符始终指向一个实体</li>
<li>使用位串来表示</li>
</ul>
</li>
<li>易于理解的名称：为用户指定，字符串表示</li>
</ul>
<h3 id="给定实体的一个无结构的名称（如标识符）如何定位该实体？（移动实体定位的方法有哪些？）"><a href="#给定实体的一个无结构的名称（如标识符）如何定位该实体？（移动实体定位的方法有哪些？）" class="headerlink" title="* 给定实体的一个无结构的名称（如标识符）如何定位该实体？（移动实体定位的方法有哪些？）"></a>* 给定实体的一个无结构的名称（如标识符）如何定位该实体？（移动实体定位的方法有哪些？）</h3><ul>
<li><p>简单方法</p>
<ul>
<li><p>广播和多播</p>
<p>广播适用于局域网，在广域网内变得低效；多播只发送给一组符合条件的主机，可进行多播实体的定位服务，可用于定位最近副本</p>
</li>
<li><p>转发指针</p>
<p>原理是：当实体从A移动到B时，它将后面留下一个指针，这个指针指向它在B中的新位置，这种方法主要优点是它很简便：一旦找到实体以后（比如使用传统的命名服务），客户就可以顺着转发指针形成的链来查找实体的当前地址。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/67477351e1889b4627d21efb9a564c02-20230225162535560-48376f.png" alt="image-20230206014328469"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/17c9e2c16c272629535d291ea71be7d9-20230225162554106-e7fbba.png" alt="image-20230206014338517"></p>
</li>
</ul>
</li>
<li><p>基于起始位置的方法</p>
<p>原理是：每个移动主机都是用一个固定的IP地址，所有与该IP地址进行的通信一开始都被转发到移动主机的宿主代理（home agent）中。宿主代理位于局域网中，与包含在移动主机IP地址中的网络地址相对应。当一台移动主机转移到另一个网络中时，它会请求一个可以用来通信的临时地址。这种转交地址（care-of address）要在宿主代理中注册。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/ea9d60840e26dcbb8c51d85437902ec2-20230225162602663-a30fca.png" alt="image-20230206014841256"></p>
</li>
<li><p>分层方法</p>
<p>如下图所示，具体细节在下一节中。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/0e05ae61a2ba9812a5f918f31ab032c3-20230225162609678-1050bf.png" alt="image-20230206015048943"></p>
</li>
</ul>
<h3 id="分层方法介绍"><a href="#分层方法介绍" class="headerlink" title="* 分层方法介绍"></a>* 分层方法介绍</h3><ul>
<li><p>类似DNS 网络被划分为一组域</p>
</li>
<li><p>目录节点：记录域包含的实体</p>
<ul>
<li>叶域的目录节点N记录实体E在域中的位置</li>
<li>更高一层域的目录节点N’记录实体E的位置，包含指向N的指针</li>
</ul>
<p>这些节点构成一个目录节点树，顶级域的目录节点称为根（目录）节点，包含有全部的实体；根节点拥有每个实体的位置记录，其中每条位置记录都存储一个指向更底层子域目录节点的指针，该记录关联的实体当前就位于这里</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/dba06c0fcf73a5e7331032925da3d0d2-20230225162616019-a68349.png" alt="image-20230205185836239"></p>
</li>
<li><p>实体可以拥有多个地址，比如它被复制了，就会出现这种情况，如果实体分别在叶域D1和D2中拥有地址，那么同时包含D1和D2的最小域的目录节点将有两个指针，每个指针都指向一个包含地址的子域，也就是下图中的效果（通用组织树）</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/8a1af3f6ff40b53764d04819858f2fb2-20230225162620601-7accf7.png" alt="image-20230205191704027"></p>
</li>
</ul>
<h3 id="描述分层方法中查找一实体的过程"><a href="#描述分层方法中查找一实体的过程" class="headerlink" title="描述分层方法中查找一实体的过程"></a>描述分层方法中查找一实体的过程</h3><p>如下图所示，希望定位实体E的客户指向它所在的叶域D的目录节点发送一个查找请求。如果这个目录节点没有存储该实体的位置记录，那么就说明该实体不在D中。因此，这个节点会把请求转发给它的父节点。注意，这里父节点代表一个比它的子域更大的域，如果父节点也没有E的位置记录，那么就会把该查找亲求转发给更高一层的域，以此类推。</p>
<p>如果节点M存储了E的位置记录，那么一旦请求到达M后，就可以知道E位于节点M代表的域dom（M）中。如下图所示，M存储了一条位置记录，其中包含一个指向其子域的指针。然后，把请求转发给那个子域的目录节点，那个子域会依次进一步向树的下方转发请求，直到请求最终到达叶节点位置。存储在叶节点中的位置记录会包含E在哪一个叶域中的地址。这样就可以把这个地址返回给发起请求的客户。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/b32576298dd9e3e1bce61e53dc5d31ad-20230225162629759-796a60.png" alt="image-20230205191727779"></p>
<p>一个与分层定位服务有关的重要因素是，查找操作是在局部进行的。原则上，对实体的搜索实在一个以发出查找请求的客户为中心，逐步增大的环中进行的。每当查找请求被转发到更高一层的目录节点是，都会扩大搜索区域。在最差情况下，搜索会连续进行。直至请求到达根节点为止。由于根节点拥有所有实体的位置记录，所以此时可以简单地沿着一条向下的指针路线把请求转发给一个叶节点。</p>
<h3 id="描述分层方法中插入一实体的过程"><a href="#描述分层方法中插入一实体的过程" class="headerlink" title="描述分层方法中插入一实体的过程"></a>描述分层方法中插入一实体的过程</h3><p>更新操作以与查找类似的方式在局部进行，如下图所示。假设实体E在叶域D中创建了一个副本，就需要插入这个副本的地址。插入操作从D的叶节点dir（D）开始，然后D会立即把插入请求转发给父节点。父节点同样会转发插入请求，直到插入请求到达已经为E存储了位置记录的目录节点M为止。</p>
<p>然后，节点M会在E的位置记录中存储一个指针，该指针指向转发插入请求的那个子节点。此时，该子节点会建立一条关于E的位置记录，该位置记录中包含一个指针，指向转发请求的下一层节点。这个过程会连续进行，直至到达发起请求的叶节点为止。最后那个叶节点会创建一条记录，这条记录包含实体在叶域中的位置。</p>
<p>也就是，插入请求转发到第一个知道实体E的节点；转发指向叶节点的指针所形成的链</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/57fba60d21fbe2d275eab24b5cde7adf-20230225162636808-6d9812.png" alt="image-20230205193234616"></p>
<p>刚才介绍的插入地址操作会导致一条从上到下建立的指针链，它从一个最底层的目录节点开始，该节点拥有实体E的位置记录。另一种是在向父节点发送插入请求之前创建一条位置记录。换句话说，就是从下往上建立指针链。后者的优点是地址会尽快变得可用。这样的话，即使父节点暂时无法到达，仍然可以在当前节点所在的域内查找实体的地址。</p>
<h3 id="描述分层方法中删除一实体的过程"><a href="#描述分层方法中删除一实体的过程" class="headerlink" title="* 描述分层方法中删除一实体的过程"></a>* 描述分层方法中删除一实体的过程</h3><p>删除操作与插入操作类似。如果需要删除叶域D中实体E的地址，那么需要请求目录节点dir（D）从它为E存储的位置记录中删除该地址。如果那条位置记录变成了空的，也就是说，它不在包含其他E在D中的地址，那么这条记录也可以删除。在这种情况下，dir（D）的父节点需要删除指向dir（D）的指针。如果父节点中有关E的位置记录也变空了，那么也应该删除这条位置记录，并通知更高一层的节点。以此类推，这个过程将连续进行，直到从一条位置记录中删除指针后该位置记录仍然非空或者是到达根节点为止。</p>
<h2 id="C6-同步"><a href="#C6-同步" class="headerlink" title="C6 同步"></a>C6 同步</h2><h3 id="Lamport时间戳算法的思想"><a href="#Lamport时间戳算法的思想" class="headerlink" title="Lamport时间戳算法的思想"></a>Lamport时间戳算法的思想</h3><p>基于Lamport算法，一种逻辑时钟同步化算法的被称为向量时间戳的Lamport扩展算法</p>
<p>时间戳（Time-Stamping）的算法：</p>
<ul>
<li>网络上的每个系统（站点）维护一个计数器，起时钟的作用</li>
<li>每个站点有一个数字型标识，消息的格式为$(m,T_i,i)$，m为消息内容，$T_i$为时间戳，i为站点标识</li>
<li>当系统发送消息时，将时钟加一</li>
<li>当系统<code>j</code>接收消息时，将它的时钟设为当前值和到达时间戳这两者的最大值加一</li>
<li>在每个站点，时间的排序遵循以下规则：对来自站点<code>i</code>的消息x和站点<code>j</code>的消息y，如果 $T_i&lt;T_j$或$T_i=T_j$，且$i&lt;j$，则说消息x早于消息y</li>
</ul>
<p>例如下图中，消息 a 最早，接下来是消息 x，接下来是消息 b，最后是消息 j；可以看到消息 b 和消息 j 的时间戳是相同的，但是消息 b 来自站点P1，消息 j 来自站点P3，1&lt;3，因此所有站点都认同消息 b 早于消息 j 的结论。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/d59f7327a320c65750e9a5dd600fa746-20230225162652469-827afb.png" alt="image-20230206003219662"></p>
<p>类似的，在下图的例子中，消息a早于消息q</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/cabb963ad7ab6b5db41e99491502e9f0-20230225162658755-091717.png" alt="image-20230206012548962"></p>
<p>哪个事件在实际上首先发生并不重要，重要的是所有进程对事件的发生顺序意见一致</p>
<h3 id="选举算法"><a href="#选举算法" class="headerlink" title="* 选举算法"></a>* 选举算法</h3><p>选择一个进程作为协调者、发起者或其他特殊角色，一般选择进程号最大的进程（假设每个进程都知道其他进程的进程号，但不知道是否还在运行）；目的是：保证选举进行后，所有进程都认可被选举的进程。相关的算法包括：Bully算法、环算法、无线环境下的选举算法、大型系统中的选举算法。</p>
<h3 id="选举算法中Bully算法的思想"><a href="#选举算法中Bully算法的思想" class="headerlink" title="选举算法中Bully算法的思想"></a>选举算法中Bully算法的思想</h3><p>当进程P注意到需要选举一个进程作协调者时：</p>
<ul>
<li>向所有进程号比它高的进程发ELECTION消息</li>
<li>如果得不到任何进程的响应，进程P获胜，成为协调者</li>
<li>如果有进程号比它高的进程响应，该进程接管选举过程，进程P任务完成</li>
<li>当其他进程都放弃时，只剩一个进程时，该进程成为协调者</li>
<li>一个以前被中止的进程恢复后也有选举权</li>
</ul>
<p>下图例子中：</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/a0622cbf17e9d19fd7ba2c9b08060f6f-20230225162706086-0d6d36.png" alt="image-20230206013608023"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/d7864c5bd6400e2e4722e0f9508b3b8b-20230225162710951-d03633.png" alt="image-20230206013620248"></p>
<ul>
<li>进程4启动选举</li>
<li>进程5和进程6响应，接管选举，成为协调者</li>
<li>进程6响应进程5的消息，接管选举，进程6成为协调者，通知所有进程</li>
</ul>
<h3 id="选举算法中环算法的思想"><a href="#选举算法中环算法的思想" class="headerlink" title="选举算法中环算法的思想"></a>选举算法中环算法的思想</h3><ul>
<li>不使用令牌</li>
<li>按进程号排序，每个进程都知道自己的后继者</li>
<li>当进程P注意到需要选举一个进程作协调者时;<ul>
<li>就创建一条包含该进程号的ELECTION消息，发给后继进程</li>
<li>后继进程再将自己的进程号加入ELECTION消息，依此类推</li>
<li>最后回到进程P，它再发送一条COORDINATOR消息到环上，包含新选出的协调者进程（进程号最大者）和所有在线进程</li>
</ul>
</li>
</ul>
<p>具体过程如下图所示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/57250088031c1d13dce3d27b6e7bdde9-20230225162716555-be6ebf.png" alt="image-20230206015452065"></p>
<h3 id="资源图"><a href="#资源图" class="headerlink" title="* 资源图"></a>* 资源图</h3><p>下图是一种改进的资源图，图中只给出进程，每条弧穿过一个资源，为简单起见从图中删除了资源。</p>
<p>从图中可以看到：机器上的进程3正在等待两个资源，一个由进程4占有，一个由进程5占有；一些进程正在等待本地资源，例如进程1；一些进程，如进程2在等待其他机器上的资源。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/54ce7855073a8e7ba15e74eaef4cc724-20230225162729359-7a6855.png" alt="image-20230206021320865"></p>
<h3 id="分布式死锁检测Chandy-Misra-Haas算法的思想"><a href="#分布式死锁检测Chandy-Misra-Haas算法的思想" class="headerlink" title="分布式死锁检测Chandy-Misra-Haas算法的思想"></a>分布式死锁检测Chandy-Misra-Haas算法的思想</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>允许进程一次请求多个资源（加锁）而不是一次一个</p>
<ul>
<li>通过允许多个请求同时进行使得事务的增长阶段加速</li>
<li>这使得一个进程可以同时等待两个或多个进程</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>当某个进程等待资源时，例如P0等待P1，将调用Chandy-Misra-Haas算法。生成一个探测消息发送给占用资源的进程。</p>
<ul>
<li>消息由三个数组构成：阻塞的进程、发送消息的进程、接收消息的进程</li>
<li>例如，由P0到P1的初始消息包含三元组（0，0，1）</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/54ce7855073a8e7ba15e74eaef4cc724-20230225162755133-c241a1.png" alt="image-20230206021624414"></p>
<p>消息到达后，接受者检查以确认它自己是否也在等待其他进程。</p>
<ul>
<li>若是，就更新消息，字段 1 保持不变，字段 2 改成当前进程号，字段 3 改为等待的进程号</li>
<li>然后消息接着被发送到等待的进程</li>
<li>若存在多个等待进程，就要发送多个不同的消息</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/54ce7855073a8e7ba15e74eaef4cc724-20230225162802834-26c5a1.png" alt="image-20230206021821891"></p>
<p>不论资源在本地还是在远程，该算法一直继续下去。</p>
<p>下图中，（0，2，3），（0，4，6），（0，5，7）和（0，8，0）都是远程消息。</p>
<p>若消息转了一圈又回到了最初的发送者，即字段1所列的进程，就说明存在一个有死锁的环路系统。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/54ce7855073a8e7ba15e74eaef4cc724-20230225162807585-9409b9.png" alt="image-20230206022037106"></p>
<h3 id="打破死锁的方法"><a href="#打破死锁的方法" class="headerlink" title="* 打破死锁的方法"></a>* 打破死锁的方法</h3><p>可以有不同的方法打破死锁：</p>
<ul>
<li>一种方法是使最初发送探测消息的进程自杀。如果有多个进程同时调用了此算法，那就会出现问题。例如在上节例中假设进程0-6同时阻塞，而且都初始化了探测消息。那么每个进程都会发现死锁，并且因此而自杀，然而这是不必要的。终止掉一个进程就足够了。</li>
<li>另一种算法是将每个进程的标识符添加到探测消息的末尾，这样当它返回到最初的发送者时，完整的环路就可以列出来了。于是发送者就能看出哪个进程编号最大，可以将它终止或者发送一个消息给它请求其自杀。</li>
<li>无论如何，如果多个进程同时发现了同一个环路，它们就一定会选择同一个牺牲者。</li>
</ul>
<h2 id="C7-一致性和复制"><a href="#C7-一致性和复制" class="headerlink" title="C7 一致性和复制"></a>C7 一致性和复制</h2><h3 id="复制的目的和代价"><a href="#复制的目的和代价" class="headerlink" title="复制的目的和代价"></a>复制的目的和代价</h3><ul>
<li><p>可靠性</p>
</li>
<li><p>性能</p>
<ul>
<li>服务器数量扩展</li>
<li>地理区域扩展</li>
</ul>
</li>
<li><p>代价：一致性</p>
<ul>
<li>网络通信开销</li>
<li>强一致性要求的原子操作很难快速完成</li>
</ul>
<p>解决办法：放宽一致性方面的限制，放宽程度取决于复制数据的访问和更新模式以及数据的用途</p>
</li>
</ul>
<h3 id="以数据为中心的一致性模型"><a href="#以数据为中心的一致性模型" class="headerlink" title="* 以数据为中心的一致性模型"></a>* 以数据为中心的一致性模型</h3><ul>
<li>讨论共享数据读操作和写操作时的一致性问题</li>
<li>一致性模型实质上时进程和数据存储间的约定：如果进程同意遵守某些规则，数据存储将正常进行。正常情况下，进程的读操作应该返回最后一次写操作的结果</li>
<li>没有全局时钟，精确定义哪次操作是最后一次写操作是困难的</li>
<li>作为全局时钟的替代，产生了一系列一致性模型，每种模型都有效地限制了一个数据项上执行一次读操作所应返回的值</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/9fffbc2c2aef2aeb8f0228b698650a13-20230225162814737-15f7ba.png" alt="image-20230206162129807"></p>
<h3 id="能区分是否符合严格一致性、顺序一致性、因果一致性和FIFO一致性"><a href="#能区分是否符合严格一致性、顺序一致性、因果一致性和FIFO一致性" class="headerlink" title="能区分是否符合严格一致性、顺序一致性、因果一致性和FIFO一致性"></a>能区分是否符合严格一致性、顺序一致性、因果一致性和FIFO一致性</h3><ol>
<li><p>严格一致性（Strict Consistency）：</p>
<ul>
<li>任何对数据项X的读操作将返回最近一次对X进行写操作的值</li>
<li>对所有进程来说，所有写操作都是瞬间可见的，系统维护着一个绝对的全局时间顺序</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/89e232fcffec7a4048c1c9c22758d05d-20230225163642219-cd9384.png" alt="image-20230206162412639"></p>
<p>上图中：a) 严格的一致性存储；b)非严格的一致性存储</p>
</li>
<li><p>顺序和线性化一致性（Sequential and Linearizability Consistency）</p>
<p>2.1 顺序一致性</p>
<p>顺序一致性对存储器的限制比严格一致性要弱一些，要满足以下的条件：</p>
<ul>
<li>每个进程的内部操作顺序是确定不变的</li>
<li>加入所有的进程都对某一个存储单元执行操作，那么，它们的操作顺序是确定的，即任一进程都可以感知到这些数据同样的操作顺序</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/c69f9bf4975b3a69e0a9ecfbef0b165c-20230225163656773-385c3b.png" alt="image-20230206163259554"></p>
<p>上图中：a) 顺序一致的数据存储；b) 非顺序一致的数据存储</p>
<p>2.2 线性化</p>
<ul>
<li>弱于严格一致性而强于顺序一致性</li>
<li>根据一系列时钟同步确定顺序（利用时间戳）</li>
</ul>
<p>顺序一致性和线性化提供了程序开发人员在并发程序设计中期望的语义：所有写操作都已相同的顺序被每个进程看到</p>
</li>
<li><p>因果一致性（Casual Consistency）</p>
<ul>
<li>所有进程必须以相同的顺序看到具有潜在因果关系的写操作</li>
<li>不同机器上的进程可以以不同的顺序看到并发的写操作</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/740a629c165fa031ddef5ae5b88f1bf9-20230225163733653-f19547.png" alt="image-20230206163633652"></p>
<p>上图是，因果一致性存储允许的，但顺序和严格一致性存储不允许的顺序</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/e15a59876bfbdbe51469d2a123d34557-20230225163806792-d2dde3.png" alt="image-20230206163943745"></p>
<p>上图中：a) 违背因果一致性的时间存储顺序；b) 符合因果一致性的时间存储顺序</p>
</li>
<li><p>FIFO一致性（FIFO Consistency）</p>
<p>FIFO一致性模型是在因果一致性模型上的进一步弱化，它满足下面的条件：</p>
<ul>
<li>由某一个进程完成的写操作可以被其他所有的进程按照顺序感知到，而从不同进程中来的写操作对不同的进程可以有不同的顺序。</li>
</ul>
<p>下图是一个符合FIFO一致性的时间存储顺序</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/7ee2a995554af4f74ab517ad09f698d4-20230225163829941-5cbdd7.png" alt="image-20230206164253123"></p>
<p>FIFO一致性与顺序一致性的区别：</p>
<ul>
<li>顺序一致性：尽管语句的执行顺序是非确定的，但所有的进程对顺序达成一致。</li>
<li>FIFO一致性：各个进程不需要达成一致，不同进程可以以不同的顺序看到</li>
</ul>
</li>
<li><p>一致性总结</p>
<p>| 一致性（Consistency） | 描述（Description）                                          |<br>| ——————————- | —————————————————————————————— |<br>| 严格                  | 所有共享访问按绝对时间排序                                   |<br>| 线性化                | 所有进程以相同顺序看到所有的共享访问。而且，访问时根据全局时间戳排序的 |<br>| 顺序                  | 所有进程以相同顺序看到所有的共享访问。访问不是根据时间排序的 |<br>| 因果                  | 所有进程以相同顺序看到因果相关的共享访问                     |<br>| FIFO                  | 所有进程以不同进程提出写操作的顺序相互看到写操作。来自不同进程的写操作可以不必总是以相同的顺序出现 |</p>
</li>
</ol>
<h3 id="以客户为中心的一致性模型"><a href="#以客户为中心的一致性模型" class="headerlink" title="* 以客户为中心的一致性模型"></a>* 以客户为中心的一致性模型</h3><ol>
<li><p>最终一致性（Eventual Consistency）</p>
<ul>
<li>最终一致性：很多情况下系统能容忍相对较高程度的不一致性，共同之处在于：只有一个或少数几个进程执行更新操作，如果较长时间内没有更新操作，那么副本将逐渐成为一致的；例如：数据库系统，DNS，WWW</li>
<li>特点：只有少数几个进程执行更新操作，只需要处理读写冲突；能够容忍相对较高程度的不一致性；实现开销小。</li>
<li>如果客户总是访问同一副本，最终一致性能工作得很好</li>
</ul>
</li>
<li><p>以客户为中心的一致性模型不考虑数据可能被多个用户共享的问题，而是集中考虑一个单独用户应被提供的一致性。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/7beebeb518729e9bd7c2a3835dd40748-20230225163843059-db4932.png" alt="image-20230206170755398"></p>
<p>上图是用户访问分布式数据库不同副本的原理</p>
</li>
</ol>
<h3 id="能区分是否符合单调读、单调写、写后读和读后写"><a href="#能区分是否符合单调读、单调写、写后读和读后写" class="headerlink" title="能区分是否符合单调读、单调写、写后读和读后写"></a>能区分是否符合单调读、单调写、写后读和读后写</h3><p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/89e232fcffec7a4048c1c9c22758d05d-20230225163852481-2de3c2.png" alt="image-20230206023858712"></p>
<p>上图来自于题目，应该属于以数据为中心的一致性</p>
<ol>
<li><p>单调读（Monotonic Reads）</p>
<p>定义：如果一个进程读取数据项x的值，那么该进程对x执行的任何后续读操作将总是得到第一次读取的那个值或更新的值</p>
<p>下图中描述了，进程P对同一数据存储的两个不同本地副本执行的读操作；L1，L2表示数据存储的两个不同的本地副本，水平轴表示时间。WS（x1；x2）表示WS（x1）的操作已在L2更新完毕。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/ceb0375c20516c11ef79bc03564913dd-20230225163858123-d13224.png" alt="image-20230206180819954"></p>
<p>图（a）表示保证单调读一致性的情况。图 (a) 中，进程P先在L1对x执行了一次读操作。该值是在L1执行的WS（x1）的结果。后来，P在L2对x执行了一次读操作，及图中的R（x2）。为了保证单调读一致性，WS（x1）中的所有操作都应该在执行第二个读操作前传播到L2。也就是说，我们需要确保WS（x1）是WS（x2）的一部分，记为WS（x1；x2）。</p>
<p>与之相对照，图（b）表示不保证单调读一致性的情况。进程P在L1读取x1后，由在L2执行R（x2）操作。然而，L2只执行了WS（x2）中的写操作。此时，不能保证集合WS（x2）同样包含WS（x1）中的所有操作。</p>
</li>
<li><p>单调写（Monotonic Writes）</p>
<p>定义：一个进程对数据项x执行的写操作必须在该进程对x执行的任何后续写操作之前完成</p>
<blockquote>
<p>通过上述定义可看出，完成一个写操作意味着不管后续操作的启动位置，执行这个后续操作的副本都能反映出先前执行的写操作结果。也就是说，在数据项x的副本上执行的写操作只有在该副本已经通过任何先前的写操作进行更新之后才能被执行，而这些先前执行的写操作可能发生在x的其他副本上。</p>
</blockquote>
<p>单调写一致性与以数据为中心的FIFO一致性类似。FIFO一致性的本质是，同一进程执行的写操作必须在任何地方以正确的顺序执行。这一顺序限制也适用于单调写一致性，只是我们这里考虑的是仅为单一进程维持的一致性，而不是为许多并发进程维持的一致性。</p>
<blockquote>
<p>每个写操作完全覆盖x的当前值时，没有必要将x的副本更新为最新值，写操作通常指修改数据项的部分状态。</p>
</blockquote>
<p>下图中描述了，进程P对同一数据存储的两个不同本地副本执行的写操作；图（a）为提供单调写一致性的数据存储；图（b）为不提供单调写一致性的顺序存储。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/b7b2de3ccfedd5dd7d6aff266c31ec38-20230225163938357-7ec080.png" alt="image-20230206195722821"></p>
<p>图（a）中，进程P在本地副本L1对x执行一次写操作，记为操作W（x1）。然后，进程P对x再执行一次写操作，但是这次是在L2出执行，如图中的W（x2）。为了保证单调写一致性，先前在L1执行的写操作必须已经传遍到L2。这就解释了图中L2处出现操作WS（x1），以及它出现在W（x2）之前的原因。</p>
<p>与之相对照，图（b）表示不保证单调写一致性的情况。与图（a）相比，图中没有向副本L2传播的W（x1）。也就是说，它不能保证x的副本上执行第二次写操作时，x的副本的值与执行完W（x1）时二点值相同或比之更新。</p>
</li>
<li><p>写后读（读写一致性，Read Your Writes）</p>
<p>定义：一个进程对数据项x执行的写操作总会被该进程对x执行的任何后续读操作看见</p>
<p>也就是说，一个写操作总是在同一进程执行的后续读操作之前完成，而不管这个后续读操作发生在什么位置。</p>
<p>下图（a）中描述了一个提供写后读一致性的数据存储；图（a）（b）非常相像，只是这里的一致性是通过进程P执行的最后一次写操作确定的，而不是通过进程P的最后一次读操作确定；图（a）为提供写后读一致性的数据存储；图（b）为不提供写后读一致性的顺序存储。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/21d1ecf5bb8e0ed36184e3b958acf181-20230225163951123-e5f6b8.png" alt="image-20230206201539581"></p>
<p>在图（a）中，进程P执行了一次写操作W（x1），然后在一个不同的本地副本处执行了一次读操作。写后读一致性保证，写操作的结果可以被所有后续的读操作看到。这一过程表示为WS（x1；x2），它表示W（x1）是WS（x2）的一部分。与之相对照，在图（b）中，W（x1）不在WS（x2）之中，这意味着进程P执行前一个写操作的结果还没有传播到。</p>
</li>
<li><p>读后写（写读一致性， Writes Follows Reads）</p>
<p>定义：同一个进程对数据项x执行的读操作之后的写操作，保证发生在与x读取之相同或更新的值上。</p>
<p>也就是说，进程对数据项x所执行的任何后续写操作都会在x的副本上执行，而该副本是用该进程最近读取的值更新的。</p>
<p>下图中描述了一个提供读后写一致性的数据存储；图（a）为提供读后写一致性的数据存储；图（b）为不提供读后写一致性的顺序存储。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/631cbdbff030ef7a3c155e6a50c73924-20230225163958816-ee944c.png" alt="image-20230206202159536"></p>
<p>在图（a）中，一个进程在本地副本L1处读取x。写入刚才所读取值的写操作也出现在L2处的写操作集合中。稍后，同一进程在L2处执行了一次写操作。注意，L2处的其他进程也看到了那些写操作。而图（b）中的数据存储无法保证L2处执行的操作是在与L1处所读的那个副本一致的副本上执行的。   </p>
</li>
</ol>
<h3 id="基于主备份的协议：远程写协议、本地写协议"><a href="#基于主备份的协议：远程写协议、本地写协议" class="headerlink" title="基于主备份的协议：远程写协议、本地写协议"></a>基于主备份的协议：远程写协议、本地写协议</h3><ul>
<li><p>基于主备份的协议：每个数据x都有一个关联的主备份，负责协调x的写操作，根据主备份的位置分为：远程写协议，本地写协议</p>
</li>
<li><p>远程写协议</p>
<ul>
<li>基于主备份的远程写协议，所有读操作和写操作都被转发到一个固定的服务器上</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/4ce6e085d17a92c3bcd3606feafa93d2-20230225164004089-ac4a2e.png" alt="image-20230206221419729"></p>
<ul>
<li><p>允许进程在本地可用的副本上执行读操作，但必须向一个固定的主拷贝上转发写操作</p>
</li>
<li><p>提供实现顺序一致性的直接方法</p>
</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/ec6eff30d59f5eefa2e25e303b38e2df-20230225164011373-5b8287.png" alt="image-20230206221335448"></p>
</li>
<li><p>本地写协议</p>
<ul>
<li>基于主备份的本地写协议，其中一个单一的拷贝在多个进程间移动</li>
<li>保证一致性</li>
<li>需要跟踪数据项的当前位置：广播、转发指针、基于原始位置的方法和层次定位服务。</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/0351f597065172605bc2004fa3d53204-20230225164214337-63b66e.png" alt="image-20230206222403651"></p>
<ul>
<li>多个连续的写操作可在本地进行，而读操作的进程还可以访问它们的本地拷贝</li>
<li>支持离线操作</li>
<li>主机备份协议，其中主备份移动到要执行更新的进程那里</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/0438272462670544b33948dfff7f22f8-20230225164223297-9fa4b2.png" alt="image-20230206222602702"></p>
</li>
</ul>
<h3 id="复制的写协议：主动复制、基于法定数目的协议"><a href="#复制的写协议：主动复制、基于法定数目的协议" class="headerlink" title="复制的写协议：主动复制、基于法定数目的协议"></a>复制的写协议：主动复制、基于法定数目的协议</h3><ul>
<li><p>复制的写协议：写操作可以在多个副本上执行</p>
</li>
<li><p>主动复制</p>
<ul>
<li>写操作可以在多个副本上执行，每个副本对应一个进程，该进程执行更新操作</li>
<li>写操作导致更新传播</li>
<li>操作需要在各地按相同顺序进行：<ul>
<li>时间戳(Lamport)</li>
<li>定序器</li>
</ul>
</li>
</ul>
</li>
<li><p>基于法定数目（多数表决）的协议</p>
<ul>
<li><p>要更新一个文件，必须先联系至少半数加一个服务器，并得到它们同意后执行更新，修改文件后这些服务器上的文件将得到一个新的版本号；要读取一个文件，必须联系至少半数加一个服务器，请求它们返回该文件关联的版本号，若版本号一致则该版本为最新版本，因为剩余服务器的个数不够半数以上，试图只更新剩余服务器的请求将会失败。</p>
</li>
<li><p>Gifford方法：客户在读写一个复制的数据时，先向多个服务器提出请求，获得许可；读团体$N_R$，写团体$N_W$，$N$个副本；满足$N_R+N_W&gt;N,且 N_W&gt;N/2$</p>
</li>
<li>Gifford方法中，上述第一个条件用于防止读写操作冲突；而第二个限制条件用于防止读读操作冲突。只有在适当个数的服务器同意参与文件的读写后，客户才能读或写该文件。</li>
<li>下图中的三个实例：(a) 读集合和写集合的正确选择；(b)可能导致写写冲突的读集合和写集合，例如两个写集合{A, B, C, E, F, G}和{D, H, I, J, K, L}就会发生写写冲突；(c)读集合和写集合的正确选择，ROWA（read one, write all）。</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/d84be3835f882616a8d4739f3e0f4a0f-20230225164232180-5e9eb0.png" alt="image-20230206223622108"></p>
</li>
</ul>
<h2 id="C8-容错性"><a href="#C8-容错性" class="headerlink" title="C8 容错性"></a>C8 容错性</h2><h3 id="什么是容错性"><a href="#什么是容错性" class="headerlink" title="什么是容错性"></a>什么是容错性</h3><ul>
<li>容错意味着系统即使发生故障也能提供服务</li>
<li>容错与可靠性相联系，包含以下需求：<ul>
<li>可用性（Availability）：任何给定的时刻都能及时工作</li>
<li>可靠性（Reliability）：系统可以无故障地持续运行</li>
<li>安全性（Safety）系统偶然出现故障能正常操作而不会造成任何灾难</li>
<li>可维护性（Maintainability）发生故障的系统被恢复的难易程度</li>
</ul>
</li>
</ul>
<h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><p>这里被用于描述分布式系统中的进程故障，故障进程无法发送信息或发出干扰信息，影响其他进程的正常工作，导致系统一致性出现问题。</p>
<p>在拜占庭将军问题中，叛将代表故障进程，忠将代表正常进程。</p>
<p>Lamport的论文中提到的算法指出：如果存在k个叛将（故障进程），那么至少需要总共N=3k+1个将军（进程），才能最终达到一致的行动方案。</p>
<p>例如，下图中，有三个忠诚将军和一个叛将，叛将（故障进程）的代号是3，其余是忠诚将军（无故障进程），也就是k=1，N=4；简单来说，图（a）为将军宣布他们的兵力，图（b）为在（a）基础上每个将军收到的兵力组成的向量，图（c）为每个将军收到的向量；更具体地说，算法分为四步进行。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/afafa78afd0ea5ee7e77eb1b8f9516a8-20230225164514548-df2246.png" alt="image-20230207121836845"></p>
<ol>
<li>如图（a）；每个无故障进程 i 使用可靠单播给其他每个进程发送 vi ，这里假设 vi=i；故障进程则可能发送其他内容，且故障进程可能给不同进程发送不同的值，例如上图中故障进程3给其他进程1，2，4分别发送x，y，z。</li>
<li>如图（b）；每个进程把第一步收到的结果组织成向量形式。</li>
<li>如图（c）；把组织好的向量发送给其他进程，此时，每个进程将得到来自其他三个进程的三个向量；由于进程3是故障的，产生了$a-l$共12个值。</li>
<li>每个进程检查每个接收到向量中的第 i 个元素。如果存在占多数的值，那就将占多数的值放置到结果向量中；如果不存在占多数的值，那么结果向量的相应元素就标记为未知（UNKNOWN）。从（c）中可以看出，1、2、4都与v1、v2、v4的值一致，是正确的结果。从这些进程得出的结论无法确定v3，但也是不相关的。拜占庭协定的目标是一致性意见只与无故障进程的值有关。</li>
</ol>
<p>下图中，有两个忠诚将军和一个叛将，叛将（故障进程）的代号是3，其余是忠诚将军（无故障进程），也就是k=1，N=3；在图（c）中，无故障进程的向量中无法看到元素1、2和3占大多数的情况，因此都标记为未知，该算法不能产生协定。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/855b3c189e1cc86c3fe603a4d8cf0415-20230225164523812-c36934.png" alt="image-20230207132659842"></p>
<p>一些网络上的参考资料对拜占庭将军问题做了更加具体的说明。</p>
<blockquote>
<p>拜占庭将军问题(The Byzantine Generals Problem)提供了对<strong>分布式共识问题</strong>的一种情景化描述, 由Leslie Lamport等人在1982年首次发表. <a href="https://www-inst.eecs.berkeley.edu/~cs162/sp16/static/readings/Original_Byzantine.pdf" target="_blank" rel="noopener">论文</a>同时提供了两种解决拜占庭将军问题的算法：</p>
<ul>
<li>口信消息型解决方案(A solution with oral message);</li>
<li>签名消息型解决方案(A solution with signed message).</li>
</ul>
<p>本文之后将详细讲述这两种算法. 事实上, 拜占庭将军问题是分布式系统领域最复杂的<strong>容错模型</strong>, 它描述了如何在存在恶意行为(如消息篡改或伪造)的情况下使分布式系统达成一致. 是我们理解分布式一致性协议和算法的重要基础.</p>
</blockquote>
<p>参考：</p>
<p><a href="https://www.zhihu.com/question/23167269" target="_blank" rel="noopener">如何理解拜占庭将军问题？</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/107439021" target="_blank" rel="noopener">拜占庭将军问题 (The Byzantine Generals Problem)</a></p>
<p><a href="https://liebing.org.cn/2020/02/14/byzantine_generals_problem/" target="_blank" rel="noopener">拜占庭将军问题 (The Byzantine Generals Problem)</a></p>
<p><a href="https://baike.baidu.com/item/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98/265656" target="_blank" rel="noopener">拜占庭将军问题</a></p>
<p><a href="https://yeasy.gitbook.io/blockchain_guide/04_distributed_system/bft" target="_blank" rel="noopener">拜占庭问题与算法</a></p>
<h3 id="什么叫原子多播"><a href="#什么叫原子多播" class="headerlink" title="什么叫原子多播"></a>什么叫原子多播</h3><ul>
<li>可实现存在进程失败情况下的可靠多播·</li>
<li>原子多播：<ul>
<li>消息要么发送给所有进程，要么一个也不发送</li>
<li>通常需要所有的消息都按相同的顺序发送给所有的进程</li>
<li>分布式系统中的复制数据库</li>
<li>原子多播确保没有故障的进程对数据库保持一致；当一个副本从故障恢复并重新加入组时，原子多播强制它与其他组成员保持一致</li>
</ul>
</li>
<li>原子多播=虚拟同步+消息排序</li>
</ul>
<h3 id="虚拟同步"><a href="#虚拟同步" class="headerlink" title="* 虚拟同步"></a>* 虚拟同步</h3><ul>
<li><p>虚拟同步：</p>
<ul>
<li>保证多播到组试图的消息被传送给组中的每个正常进程</li>
<li>如果发送消息的进程在多播期间失败，则消息或者传递给剩余的所有进程，或者被每个进程忽略</li>
<li>所有多播都在视图改变之间进行</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/de191e62a410a1de9a9080b26b0ec330-20230225164534220-23dbf4.png" alt="image-20230207133957590"></p>
</li>
<li><p>保证发送到组视图G的所有消息在组成员关系改变之前发送到G中的所有正常进程</p>
<ul>
<li>进程4注意到进程7已经崩溃，发送一个视图改变</li>
<li>进程6发送所有的不稳定消息（所有进程都收到的消息称为稳定消息）然后发送一个flush消息</li>
<li>当进程6从其他每个进程收到flush消息后，建立一个新的视图</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/a21a65e80115c2e2216e7fd221d31d11-20230225164542700-f77e9b.png" alt="image-20230207134226414"></p>
</li>
</ul>
<h3 id="消息排序"><a href="#消息排序" class="headerlink" title="* 消息排序"></a>* 消息排序</h3><p>通常有以下四种排序方法</p>
<ul>
<li><p>可靠不排序的多播：对接收不同进程发送的消息的次序不做任何保证</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/b839b1144a067878497e5e460fa970fe-20230225164548310-384948.png" alt="image-20230207142405374"></p>
</li>
<li><p>FIFO顺序的多播：按照消息发送的顺序传送同一进程的消息，对不同进程发送的消息的传送顺序没有约束</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/37a58a679ee3460a4ee84c702a3f768e-20230225164601343-a9f343.png" alt="image-20230207142419143"></p>
</li>
<li><p>按因果关系排序的多播：按因果关系排序多播来保留消息间的因果关系</p>
</li>
<li><p>全序多播：无论消息传送是无序、FIFO顺序还是按因果关系排序，对所有的组成员按相同的次序传送</p>
</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/4c77cebab4c0375c490a4549ba4b4d81-20230225164640389-e78c3a.png" alt="image-20230207143050095"></p>
<p>提供了全序的消息传送的虚拟同步可靠多播称为原子多播</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/2713fccc8329368b3519c8cf4449b4fc-20230225164706732-71b915.png" alt="image-20230207143144331"></p>
<h3 id="分布式提交-两阶段提交的思想"><a href="#分布式提交-两阶段提交的思想" class="headerlink" title="分布式提交-两阶段提交的思想"></a>分布式提交-两阶段提交的思想</h3><p>简单、使用、可靠，成为事实上的工业标准。</p>
<p>在两阶段提交（two-phase commit protocol, 2PC）协议中，将提交分为两个阶段</p>
<ul>
<li>第一阶段（表决阶段）：事务的协调者询问各个参与者是否可以提交，此时，各个参与者将回答消息发送给协调者。协调者根据收到的消息，看是否可以真正提交。</li>
<li>第二阶段（完成阶段）：如果可以提交，则通知各参与者立即执行提交，否则，通知它们终止此事务。</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/386c4628b989ea1904741c08b6cce2b9-20230225164717877-7a4520.png" alt="image-20230207143627077"></p>
<p>下图中，图（a）为2PC中的协调者的有限状态机；图（b）为2PC中的参与者的有限状态机。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/14e891cbdd21090dd3cd8c0cbe1230cf-20230225164725514-433aca.png" alt="image-20230207144141052"></p>
<p>参与者一旦投票，则失去自主能力，必须等待协调者的最终决定，可能造成阻塞；可能的阻塞状态有：</p>
<ul>
<li>参与者在INIT状态等待协调者的VOTE_REQUEST消息</li>
<li>协调者在WAIT状态等待来自每个参与者的表决</li>
<li>参与者在READY状态等待协调者发送的全局表决消息</li>
</ul>
<p>下图中，列出了参与者P在READY状态下与另一个参与者Q联系时采取的行动。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/a47e792e29076fe1bdbf1fb860e16ef5-20230225164748861-35f73f.png" alt="image-20230207144428943"></p>
<p>当所有运行的参与者都处于READY状态时，尽管都已同意提交，但可能有崩溃的参与者（不一定同意提交），因而无法做出决定（即使选举出新的协调者），只能等待原协调者恢复。</p>
<p>下图为2PC中协调者采取的操作的伪码描述</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/465c43a8c62fc3675e0d9cf82335337b-20230225164801092-da504d.png" alt="image-20230207144632400"></p>
<p>下图为2PC中参与者采取的操作的伪码描述</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/accee5aeedd41552c485a89d0093b028-20230225164821335-d47f87.png" alt="image-20230207144735740"></p>
<p>下图中的伪码描述了处理（来自其他READY进程）决定请求的步骤</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/af8faee34de30f71a61f8fb90e8bd3b5-20230225164830344-51d9a8.png" alt="image-20230207144728855"></p>
<h2 id="C9-分布式安全"><a href="#C9-分布式安全" class="headerlink" title="C9 分布式安全"></a>C9 分布式安全</h2><h3 id="什么是机密性和完整性？"><a href="#什么是机密性和完整性？" class="headerlink" title="什么是机密性和完整性？"></a>什么是机密性和完整性？</h3><ul>
<li>机密性：系统将信息只向授权用户公开</li>
<li>完整性：对系统资源的更改只能以授权方式进行</li>
</ul>
<h3 id="对称加密系统和公钥系统的区别？"><a href="#对称加密系统和公钥系统的区别？" class="headerlink" title="对称加密系统和公钥系统的区别？"></a>对称加密系统和公钥系统的区别？</h3><ul>
<li>对称加密系统：加密与解密密钥相同，即$P=D_K(E_K(P))$</li>
<li>非对称加密系统：加密与解密密钥不同（一个公开、一个保密），但构成唯一的一对，即$P=D_{KD}(E_{KE}(P))$，也称为公钥系统</li>
</ul>
<h4 id="相关的资料-2"><a href="#相关的资料-2" class="headerlink" title="* 相关的资料"></a>* 相关的资料</h4><p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/13d572c786388b88525b356a9c5f69f4-20230225164834681-4a84ea.png" alt="image-20230207152444718"></p>
<p>对称加密系统DES</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/ead69cfb35320d7f29a9477bb78f8cf3-20230225165314916-47dad8.png" alt="image-20230207152529525"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/c29c010b65bbd848791c82eb81a9b6ca-20230225165317211-701fc0.png" alt="image-20230207152547440"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/812338a25e44ce3848c9f231f6e43c8b-20230225165325821-974fe8.png" alt="image-20230207152558120"></p>
<p>公钥加密系统RSA</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/83f35acc6c13c7e8b22226aa9a4bbfbd-20230225165319765-3f0c47.png" alt="image-20230207152621964"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/98ddbda67ab93473f49012fdc978ffe4-20230225165332461-85347a.png" alt="image-20230207152636582"></p>
<p>MD5</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/298cc7a6afcc3b2deb86045907fdc724-20230225165337399-89a6f6.png" alt="image-20230207152728932"></p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/418b25f1b51e066da16f52290e5a480f-20230225165344896-f8d5f8.png" alt="image-20230207152739661"></p>
<h3 id="什么是安全通道？"><a href="#什么是安全通道？" class="headerlink" title="什么是安全通道？"></a>什么是安全通道？</h3><p>安全通道：使客户与服务器之间的通信保持安全，免受对消息的窃听、修改和伪造的攻击。</p>
<h3 id="身份验证"><a href="#身份验证" class="headerlink" title="* 身份验证"></a>* 身份验证</h3><p>身份验证：通信双方需要验证身份</p>
<h3 id="消息的完整性和机密性"><a href="#消息的完整性和机密性" class="headerlink" title="* 消息的完整性和机密性"></a>* 消息的完整性和机密性</h3><p>消息的完整性和机密性：消息未受到窃听、修改和伪造的攻击</p>
<h3 id="阐述基于共享密钥的身份验证的思想。"><a href="#阐述基于共享密钥的身份验证的思想。" class="headerlink" title="阐述基于共享密钥的身份验证的思想。"></a>阐述基于共享密钥的身份验证的思想。</h3><p>质询-响应协议：一方向另一方质询一个响应，只有对方知道共享密钥时才能给予正确的响应。</p>
<p>下图的过程为：</p>
<ol>
<li>A希望联系B</li>
<li>B发送质询RB</li>
<li>A返回基于共享密钥加密RB后的信息$K_{A,B}(R_B)$</li>
<li>接下来A发送质询RA</li>
<li>B返回基于共享密钥加密RA后的信息$K_{A,B}(R_A)$</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/013137e078973be3c6f6356fbbecd6f0-20230225165351926-bf9ccc.png" alt="image-20230207153333219"></p>
<p>若使用三个消息代替五个，则可能会出现错误，存在被反射攻击的风险</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/17f319b050a0b0200cb0ffaad13d5cc0-20230225165358195-10b800.png" alt="image-20230207153356191"></p>
<p>原因：协议的双方在两个不同方向都使用相同的质询</p>
<p>解决：协议的双方永远使用不同的质询</p>
<p>下图描述了反射攻击的过程，攻击者C通过建立两条信道，并将第二次质询的结果，作为第一次被质询的答案返回给B，假装C知道$K_{A,B}$以达到欺骗B冒充A的目的。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/d4fc1715e55e947ec62de19796383315-20230225165406332-514046.png" alt="image-20230207160207303"></p>
<h3 id="阐述使用密钥发布中心的身份验证的思想。"><a href="#阐述使用密钥发布中心的身份验证的思想。" class="headerlink" title="阐述使用密钥发布中心的身份验证的思想。"></a>阐述使用密钥发布中心的身份验证的思想。</h3><p>基于共享密钥的身份验证可能存在扩展性问题：N台主机，需要$N*(N-1)/2$个密钥</p>
<p>使用密钥分发中心(Key Distribution Center, KDC)，系统中只需要管理N个密钥</p>
<p>KDC与每台主机共享一个密钥；下图展现了向通信的两台主机分发一个密钥的过程：</p>
<ul>
<li>首先A告诉KDC期望与B通信;</li>
<li>KDC返回分别使用A与KDC之间的密钥、B与KDC之间的密钥加密后的A与B之间的密钥，即$K_{A,KDC}(K_{A,B}), K_{B,KDC}(K_{A,B})$，将上述信息分别分发给A，B；这样就可以通信了</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/adc9c73f10f8d0163c39ad6cc83a6223-20230225165411815-c1bc5c.png" alt="image-20230207163013135"></p>
<p>但上图中的方法存在缺点，A可能希望在B接收到来自KDC的共享密钥之前就开始与B建立安全通道，且需要KDC通知B进入通信中。为了解决这些问题，出现了下图中的协议；</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/be959cf378887bcd2873bbec4748d0c2-20230225165418913-90c18d.png" alt="image-20230207163832307"></p>
<p>KDC返回分别使用A与KDC之间的密钥、B与KDC之间的密钥加密后的A与B之间的密钥，即$K_{A,KDC}(K_{A,B}), K_{B,KDC}(K_{A,B})$，将上述信息都分发给A，最后由A转发给B。$K_{B,KDC}(K_{A,B})$被称为票据，显然，只有B能够使用票据，因为加密票据的密钥只有KDC与B知道。</p>
<h3 id="阐述使用公钥加密的身份验证的思想。"><a href="#阐述使用公钥加密的身份验证的思想。" class="headerlink" title="阐述使用公钥加密的身份验证的思想。"></a>阐述使用公钥加密的身份验证的思想。</h3><p>使用公钥加密的审问认证的过程如下图所示，假定A、B都拥有彼此的公钥。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/bed75411d607e2dc2552317fe7f22e1b-20230225165424295-9bd759.png" alt="image-20230207163952758"></p>
<p>具体过程为：</p>
<ul>
<li>A向B发送一个是使用B的公钥$K_B^+$加密的质询RA，显然只有拥有B的私钥的人才能够解密该信息</li>
<li>B接收到信息后，会返回解密过后的质询RA、对A的质询RB、用于更进一步通信的会话密钥$K_{A,B}$；上述返回的信息均使用A的公钥$K_A^+$加密</li>
<li>最后，A返回一个使用会话密钥$K_{A,B}$对质询RB加密后的信息给B，证明确实是AB之间在交谈。这样连接就建立完毕，可以进行后续的对话</li>
</ul>
<h3 id="使用公钥加密对消息进行数字签名的思想。"><a href="#使用公钥加密对消息进行数字签名的思想。" class="headerlink" title="使用公钥加密对消息进行数字签名的思想。"></a>使用公钥加密对消息进行数字签名的思想。</h3><p>数字签名：</p>
<ul>
<li>如果消息签名检验为真，发送者不能否认消息签名这一事实</li>
<li>消息与其签名的唯一关联防止了对消息进行修改而未发现的可能</li>
<li>使用公钥加密对消息进行数字签名</li>
</ul>
<p>下图描述了使用公钥加密对消息进行数字签名的过程。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/46c684df435f62099d31094340c0900e-20230225165429001-32566e.png" alt="image-20230207171804699"></p>
<p>首先A，对原始消息m使用A的私钥$K_A^-$加密，作为签名，接下来为了使消息保密发出，使用B的公钥$K_B^+$进行第二轮加密，之后向B发出。</p>
<p>B收到消息后，首先使用B的私钥$K_B^-$解密，接下来使用A的公钥$K_A^+$解密，最后得到原始的信息；如果保证公钥确实属于A，那么解密m的签名版本以及成功地与m进行比较只能意味着该消息来自A。A受到防止B对m进行任何恶意修改的保护，因为B必须一直证明m的修改版本也是由A签名的。换句话说，经解密的消息本身在本质上从来不能作为证据。</p>
<p>但是上述方法还存在问题。比如：</p>
<ul>
<li>A可以声称其私钥在消息发送前被盗了</li>
<li>A可以改变其私钥</li>
<li>使用私钥加密整个消息的开销可能会过大；可使用消息摘要解决，消息摘要是固定长度的位串h=H(m), m是任意长度的消息，H是加密散列函数</li>
</ul>
<p>下图描述了使用消息摘要对消息进行数字签名的过程</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/889340a7f224d40918d336abee69fab5-20230225165435440-38f06c.png" alt="image-20230207174356982"></p>
<p>上图中，消息摘要使用A的私钥加密后发送，消息使用明文发送，若需要保密可使用B的公钥加密后发送；B得到消息与加密后的摘要后，单独计算消息摘要，得到所接收消息的摘要，并使用A的公钥解密收到的摘要，若计算出的摘要与解密后的摘要相匹配，则证明该消息是由A签名的。</p>
<h3 id="Diffie-Hellman-建立共享密钥的原理。"><a href="#Diffie-Hellman-建立共享密钥的原理。" class="headerlink" title="Diffie-Hellman 建立共享密钥的原理。"></a>Diffie-Hellman 建立共享密钥的原理。</h3><p>原理：</p>
<ul>
<li>首先A和B双方约定两个大整数n和g，其中1&lt;g&lt;n;这两个整数无需保密，然后执行下面的过程：</li>
<li>A随机选择一个大整数x（保密），并计算$X=g^x\mod n$</li>
<li>B随机选择一个大整数y（保密），并计算$Y=g^y\mod n$</li>
<li>A把X发送给B，B把Y发送给A</li>
<li>A计算<script type="math/tex">K=Y^x\mod n = (g^y\mod n)^x\mod n=g^{xy}\mod n</script></li>
<li>B计算<script type="math/tex">K=X^y\mod n=(g^x \mod n)^y \mod n=g^{xy}\mod n</script></li>
<li>K即是共享的密钥</li>
<li>监听者在网络上只能监听到X和Y，但无法通过X、Y计算出x和y，因此无法计算出K</li>
</ul>
<p>下图描述了上述原理中的过程：</p>
<ul>
<li><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/d54842ecd37851e7972d575a0f281a3c-20230225165442831-fdcfc0.png" alt="image-20230207175948018"></li>
</ul>
<h4 id="相关的资料-3"><a href="#相关的资料-3" class="headerlink" title="* 相关的资料"></a>* 相关的资料</h4><p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/200f523a0646bf490878a65030dc9175-20230225165447607-d0ced1.png" alt="image-20230207194317233"></p>
<h3 id="权能和委派"><a href="#权能和委派" class="headerlink" title="权能和委派"></a>权能和委派</h3><h4 id="权能"><a href="#权能" class="headerlink" title="权能"></a>权能</h4><p>权能是对于指定资源的一种不可伪造的数据结构，它确切指定它的拥有者关于该资源的访问权限。</p>
<p>存在不同的权能实现方式，这里讨论的是Amoeba操作系统中所使用的实现方式。check字段用于是权能不可伪造；rights为权限位，rights在每种对象类型中的意义是不同的</p>
<p>为了调用一个对象的操作，客户必须将权能传递给服务器检查</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/3733892c65e93dd53b084b30cc63f1b0-20230225165452981-a654ca.png" alt="image-20230207184459456"></p>
<p>服务器创建对象时，客户得到是所有者权能（全1），check字段是随机选择的，同时存储在权能和服务器的一个表中</p>
<p>客户可以从一个所有者权能生成一个受限权能，并发送给另一进程</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/08e6ad1914a7f58d5a69b6f5188c423b-20230225165458741-11d080.png" alt="image-20230207184449453"></p>
<h4 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h4><p>委派：将某些访问权限从一个进程传递给另一个进程</p>
<p>例如：</p>
<p>A可以构造证书，将权限R给证书的持有者，如B；</p>
<p>A授权R给B，需要向B传递两部分内容，被称为代理，分别是证书，和证书中公钥$S^+_{proxy}$对应的私钥$S^-_{proxy}$。用于委派的一般代理结构如下所示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/77cbc9f73da2e36037b8e301457fef55-20230225165501144-340057.png" alt="image-20230207194138422"></p>
<p>证书由三部分构成，分别是权限R，公钥$S^+_{proxy}$和对证书的签名$sig(A,{R,S^+_{proxy}})$；证书可以使用明文传递。</p>
<p>公钥$S^+_{proxy}$对应的私钥$S^-_{proxy}$需要加密传递，用于检验B确实是被授权了。</p>
<p>使用代理来委派和证实访问的所有权的过程如下图所示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/62109a74d63803063fbc75e58fe21f69-20230225165505862-e9306e.png" alt="image-20230207193429269"></p>
<p>具体过程为：</p>
<ul>
<li>消息1传递委派代理给B，包括明文传递的由A签名的含有权限R和公钥$S^+_{proxy}$和密文传递的证书对应的私钥$S^-_{proxy}$</li>
<li>消息2为B希望使用A赋予的权限R，在服务器执行操作</li>
<li>消息3为服务器向B确认B是否为权限的合法所有者，即使用证书中的公钥加密一个信息N对B质询</li>
<li>消息4为B返回使用私钥解密后的结果给服务器，证明B确实是该证书的合法持有者</li>
</ul>
<p>显然，B还可以在A不知道的情况下，将权限赋予给其他人。</p>
<h2 id="C10-分布式文件系统"><a href="#C10-分布式文件系统" class="headerlink" title="C10 分布式文件系统"></a>C10 分布式文件系统</h2><h3 id="NFS的共享预约"><a href="#NFS的共享预约" class="headerlink" title="NFS的共享预约"></a>NFS的共享预约</h3><p>共享预约是一种锁定文件的隐含方法。共享预约完全独立于锁定，可用于在基于Windows的系统上实现NFS。客户打开文件时，需要指定所需的访问类型（即READ、WRITE或BOTH），以及服务器应该拒绝其他客户的访问类型。如果服务器不能满足客户的需求，那么该客户的open操作会失败。下图中确切地表示了一个新客户试图打开一个已被另一个客户成功打开的文件时的情况。对于一个已经打开的文件，使用两个不同的状态变量加以区分。访问状态表明当前客户目前如何访问该文件。拒绝状态表明新客户不要内需进行哪些访问。</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/ffdb3c58b9ba20ca062332f1aab657db-20230225165510773-22195c.png" alt="img"></p>
<p>上图中（a）表示给定一个文件的当前拒绝状态的情况下，客户试图请求以指定的访问类型打开此文件时所发生的事情；同样，（b）表示试图打开一个当前正被另一个客户访问的文件而所请求的访问类型不被该客户允许的情况。</p>
<h3 id="NFS服务器的重复请求高速缓存"><a href="#NFS服务器的重复请求高速缓存" class="headerlink" title="NFS服务器的重复请求高速缓存"></a>NFS服务器的重复请求高速缓存</h3><ul>
<li>NFS的底层RPC不能保证可靠性，而且缺乏对重复请求的检测</li>
<li>NFS服务器提供重复请求高速缓存解决：XID事务处理标识符</li>
<li>具体描述为：每个来自客户的RPC请求都有一个唯一的XID。当RPC到来时，服务器缓存该XID。只要服务器还没有发出响应。就说明正在处理这个RPC请求。当服务器处理某个请求后，也缓存该请求的关联响应，与XID相联系，再将响应返回给客户。常见下图中三种情况：</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/90296106e798f698c22fd47836545524-20230225165517352-e07200.jpeg" alt="2022第十章分布式文件系统"></p>
<ul>
<li>（a）客户端启动计时器，超时后客户仍未收到响应，因此使用原XID重发请求，若服务器收到了第一次请求但还没处理完成，则忽略第二次重发的请求</li>
<li>（b）服务器在返回响应后，收到了客户端的第二次请求，若返回响应的时间和收到第二次请求的时间接近，则忽略第二次请求</li>
<li>（c）服务器返回的响应丢失，且在相距应答发出后较远的时间收到了客户端发出的第二（或大于二）次请求，则重发该XID对应的响应结果</li>
</ul>
<h3 id="Coda的回叫（回调）承诺"><a href="#Coda的回叫（回调）承诺" class="headerlink" title="Coda的回叫（回调）承诺"></a>Coda的回叫（回调）承诺</h3><p>客户端缓存的重要性：可扩展性、容错性</p>
<p>Coda高速缓存了整个文件</p>
<p>回叫承诺：服务器记录哪些客户在本地缓存了文件的拷贝，如果文件被客户更改，会通知服务器，服务器会向其他客户发送无效化消息，（这种消息被称为回叫中断，也就是服务器废弃回叫承诺，这是因为服务器随后会将废弃它为刚刚向其发送了无效消息的客户保存的回叫承诺）如果客户在服务器上有未废弃的回叫承诺，它就可以安全地在本地访问文件。如下图中所示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/6537ce3951355162ab7b72150019fac9-20230225165522140-bbfcc1.jpeg" alt="2022第十章分布式文件系统"></p>
<p>具体为当客户A开始会话$S_A$时，服务器会记录一个回叫承诺。同样，B开始会话$S_B$时也是如此。不过，当B关闭会话$S_B$时，服务器向客户A发送回叫终端，从而终端了它对回叫客户A的承诺。注意：由于Coda的事务处理语义，当客户A关闭会话$S_A$时，不会发生任何特殊的事情，整个关闭操作就像所预期的那样被简单地接收。</p>
<p>因此，当A随后要打开会话$S_A’$时，它会发现f本地的副本是无效的，所以它必须从服务器获取最新的版本。另一方面，当B开始会话$S_B’$是，它会注意到服务器仍有一个未被废弃的回叫承诺，该承诺意味着B可简单地重用从会话$S_B$获得的本地副本。</p>
<h3 id="Coda的储藏技术"><a href="#Coda的储藏技术" class="headerlink" title="Coda的储藏技术"></a>Coda的储藏技术</h3><ul>
<li>VSG（Volume Storage Group）是一个保存同一个复制卷的服务器集合。</li>
<li>可用的VSG成员叫做AVSG（Available VSG members）。</li>
<li>Coda使用ROWA（Read One, Write ALL）来维护复制卷的一致性</li>
<li>使用版本记录方案检测不一致性</li>
</ul>
<p>下图描述了对于同一个复制文件，具有两个不同的AVSG的客户</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/ec470a5194e36ff0a24a9d4136e9d6af-20230225165529264-89f9b5.jpeg" alt="2022第十章分布式文件系统"></p>
<ul>
<li>Coda 允许客户在断开连接时（ASVG为空）的继续操作，基于本地备份，再次连接后回传服务器。基于事实：两个进程打开相同文件进行写操作很罕见。使用储藏技术（hoarding）。</li>
<li>也就是，为了成功地完成断开连接操作，需要解决的问题是确保客户缓存包含连接断开期间将访问的那些文件。如果采用简单的缓存方法，可以证明客户可能由于缺少必要的文件而不能继续执行。预先使用适当的文件填充高速缓存称为储藏。</li>
</ul>
<p>下图描述了对于一个卷，Coda客户的状态转换图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/25/08f212c9be2c45808bc0f99dbf012fec-20230225165532637-fe3545.jpeg" alt="2022第十章分布式文件系统"></p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>2023.2.8</p>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <!--<li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@mainnull"></li>-->
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/custom/donate/WechanSQ2.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2023/03/02/2022秋学期-高级操作系统期末整理-精简版/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/26/151d61752a11157cec91f00c2a37e943-20230226104700259-a12130.jpeg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/26/151d61752a11157cec91f00c2a37e943-20230226104700259-a12130.jpeg">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                2022秋学期 高级操作系统期末整理-精简版</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2023/02/12/2022秋学期-高级操作系统课件后习题/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/12/5e86e3c7e4f7209136b404eaea15d703-20230212190057-a2ed31.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://fastly.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/blogPic/2023/02/12/5e86e3c7e4f7209136b404eaea15d703-20230212190057-a2ed31.png">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                2022秋学期 高级操作系统课件后习题</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      





    <div id="tcomment"></div>
	<style>
	.el-textarea__inner{
		height: 130px;
	}
	</style>
    <script src="https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js"></script>
    <script>
    window.onload = function () {
      var loadTime = window.performance.timing.domContentLoadedEventEnd - window.performance.timing.navigationStart;
      document.getElementById("page_loading_time").innerHTML = "It took me " + loadTime + "ms to meet you this time";
      console.log('Page load time is ' + loadTime);
      // var valine = new Valine();
      // valine.init({
      //   el: '#vcomments',
      //   avatar: 'monsterid',
      //   appId: "",
      //   appKey: "",
      //   path: window.location.pathname,
      //   serverURL: "",
      //   placeholder: "你是我一生只会遇见一次的惊喜"
      // })
        twikoo.init({
          envId: 'https://vercel-for-blog.vercel.app/', // 腾讯云环境填 envId；Vercel 环境填地址（https://xxx.vercel.app）
          el: '#tcomment', // 容器元素
          // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，腾讯云环境填 ap-shanghai 或 ap-guangzhou；Vercel 环境不填
          // path: location.pathname, // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数
          // lang: 'zh-CN', // 用于手动设定评论区语言，支持的语言列表 https://github.com/imaegoo/twikoo/blob/main/src/client/utils/i18n/index.js
        })
    }
    </script>


      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="https://owuiviuwo.github.io/" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/avatar.jpg" itemprop="image" alt="owuiviuwo" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="https://owuiviuwo.github.io/" itemprop="url" rel="author">owuiviuwo</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>Learn and Live</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 owuiviuwo<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;" id="blog_running_year">&copy 2022-2023 owuiviuwo</p>
	  <p style="color: #999; font-size:10px;" id="page_loading_time"></p>
      <!--<p style="color: #666666;" id="blog_running_year">&copy <span id="blog_running_year_cal"></span> owuiviuwo</p>-->
      <p style="color: #aaa; font-size: 13px;" id="blog_running_time" ></p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> 
		<i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by 
		<a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&
		<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a><!--, Powered by Hexo, Hosted by Coding Pages</a>-->
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"0","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"0","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
//var startDay = new Date("2022-12-15");
//var nowDay = new Date();
//var dayDiff = Math.floor((nowDay-startDay)/24/60/60/1000);
//console.log("网站已运行 " + dayDiff + "天！");
//document.getElementById("blog_running_time").innerHTML = "&copy 2022-"+ nowDay.getFullYear() +" owuiviuwo";

function siteTime() {
	var seconds = 1000;
	var minutes = seconds * 60;
	var hours = minutes * 60;
	var days = hours * 24;
	var years = days * 365;
	var today = new Date();
	var startYear = "2022";
	var startMonth = "12";
	var startDate = "15";
	var startHour = "0";
	var startMinute = "0";
	var startSecond = "0";
	var todayYear = today.getFullYear();
	var todayMonth = today.getMonth() + 1;
	var todayDate = today.getDate();
	var todayHour = today.getHours();
	var todayMinute = today.getMinutes();
	var todaySecond = today.getSeconds();
	var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
	var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
	var diff = t2 - t1;
	var diffYears = Math.floor(diff / years);
	var diffDays = Math.floor((diff / days) - diffYears * 365);
	var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
	var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
		minutes);
	var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
		diffMinutes * minutes) / seconds);
		
	diffDays = diffDays < 10 ? '0' + diffDays : diffDays;
	diffHours = diffHours < 10 ? '0' + diffHours : diffHours;
	diffMinutes = diffMinutes < 10 ? '0' + diffMinutes : diffMinutes;
	diffSeconds = diffSeconds < 10 ? '0' + diffSeconds : diffSeconds;
		
//	if (startYear == todayYear) {
//		document.getElementById("blog_running_year_cal").innerHTML = todayYear;
//	} else {
//		document.getElementById("blog_running_year_cal").innerHTML = startYear + " - " + todayYear;
//	}
	if (diffYears == 0) {
		document.getElementById("blog_running_time").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
			" 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
	} else{
		document.getElementById("blog_running_time").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
			" 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
	}
}
setInterval(siteTime, 1000);
            
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
      <!-- 实现换肤功能 -->
  <div class="skin-menu no-select" id="mainskin" style="position: fixed">
 <div class="theme-controls row-container">
  <ul class="menu-list">
   <li id="white-bg"> <i class="fa fa-television" aria-hidden="true"></i></li>
   <li id="sakura-bg"> <i class="iconfont icon-sakura"></i></li>
   <li id="gribs-bg"> <i class="fa fa-slack" aria-hidden="true"></i></li>
   <li id="KAdots-bg"> <i class="iconfont icon-dots"></i></li>
   <li id="totem-bg"> <i class="fa fa-optin-monster" aria-hidden="true"></i></li>
   <li id="pixiv-bg"> <i class="iconfont icon-pixiv"></i></li>
   <li id="bing-bg"> <i class="iconfont icon-bing"></i></li>
   <li id="dark-bg"> <i class="fa fa-moon-o" aria-hidden="true"></i></li>
  </ul>
 </div>
</div>
<canvas id="night-mode-cover"></canvas> 
  <div class="changeSkin-gear no-select" >
  <div class="keys" id="setbtn"> 
   <span id="open-skinMenu"> 切换主题 | SCHEME TOOL  
     <i class="iconfont icon-gear inline-block rotating"></i> 
   </span>
  </div>
</div>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/owuiviuwo/BlogCDN@main/avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">owuiviuwo</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/owuiviuwo" class="fa " target="_blank" style="color: #; margin-left:20px"></a>
      
        <a href="https://www.cnblogs.com/owuiviuwo" class="fa " target="_blank" style="color: #; margin-left:20px"></a>
      
        <a href="https://www.zhihu.com/people/owuiviuwo" class="fa " target="_blank" style="color: #; margin-left:20px"></a>
      
        <a href="mailto:owuiviuwo@163.com" class="fa " target="_blank" style="color: #; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/生活/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/资源/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/转载/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
              <li>
                <a href="/random.html">
                  <i class="fa fa-random" aria-hidden="true"></i>
                  随机
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            数据
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/statistics/">
                  <i class="fa fa-line-chart" aria-hidden="true"></i>
                  统计
                </a>
              </li>
            
              <li>
                <a href="/postcategory/">
                  <i class="fa fa-list-ul faa-vertical" aria-hidden="true"></i>
                  分类
                </a>
              </li>
            
              <li>
                <a href="/tags/">
                  <i class="fa fa-tags" aria-hidden="true"></i>
                  标签
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/shuoshuo/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-clock-o" aria-hidden="true"></i>
            说说
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            友人帐
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/donate/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
            赞赏
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            其他
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
              <li>
                <a href="/theme-sakura/">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
              <li>
                <a href="/lab/">
                  <i class="fa fa-cogs" aria-hidden="true"></i>
                  Lab
                </a>
              </li>
            
              <li>
                <a href="/atom.xml">
                  <i class="fa fa-rss faa-pulse" aria-hidden="true"></i>
                  RSS
                </a>
              </li>
            
          </ul>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  
 

</body>
</html>