{"meta":{"title":"owuiviuwo's blog!","subtitle":":)","description":"Welcome to My site!","author":"owuiviuwo","url":""},"pages":[{"title":"about","date":"2022-12-12T14:14:36.000Z","updated":"2023-01-19T16:43:15.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"owuiviuwo 与&nbsp; owuiviuwo&nbsp; 对话中... bot_ui_ini()","keywords":"关于"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2023-02-11T12:17:10.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"分类","date":"2022-12-12T14:14:36.000Z","updated":"2023-01-22T16:08:10.000Z","comments":false,"path":"postcategory/index.html","permalink":"/postcategory/index.html","excerpt":"","text":"","keywords":"分类"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"标签","date":"2022-12-12T14:14:36.000Z","updated":"2023-01-23T14:57:00.000Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"","keywords":"标签"},{"title":"说说","date":"2022-12-12T14:14:36.000Z","updated":"2023-01-19T18:36:29.000Z","comments":false,"path":"shuoshuo/index.html","permalink":"/shuoshuo/index.html","excerpt":"","text":"new Artitalk({ appId: \"Bca3aRLRAJx2I6PNPDTapKBT-MdYXbMMI\", appKey: \"o1JOvsCvLL7SkH0kH1SeRXKK\", color1: '#E6E6FA', color2: '#F0FFFF', color3: 'black', atComment:1, })","keywords":"说说"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"统计","date":"2022-12-12T14:14:36.000Z","updated":"2023-01-24T14:52:05.000Z","comments":false,"path":"statistics/index.html","permalink":"/statistics/index.html","excerpt":"","text":"","keywords":"统计"}],"posts":[{"title":"2022秋学期 高级操作系统的整理-精简版","slug":"2022秋学期-高级操作系统的整理-精简版","date":"2023-03-02T13:43:13.000Z","updated":"2023-03-02T13:54:29.703Z","comments":true,"path":"2023/03/02/2022秋学期-高级操作系统的整理-精简版/","link":"","permalink":"/2023/03/02/2022秋学期-高级操作系统的整理-精简版/","excerpt":"","text":"2022秋学期 高级操作系统的整理-精简版封面 C0 引言本文内容来自于对高级操作系统课程资料的整理； 本文所涉及的课程指东北某沿海高校，计算机学院硕士生必修课“高级操作系统”，课程资料包括课程PPT、教材《分布式系统原理与范型 第二版》1、《Distributed Systems Principles and Paradigms 2nd edition》2，以及网络资料。 1. 《分布式系统原理与范型 第二版》 作者: （美）特尼博姆 出版社: 清华大学出版社 原作名: Distributed Systems: Principles and Paradigms 译者: 辛春生 :出版年: 2008-6-1 页数: 490 ISBN: 978730217279 &#8617; 2. 《Distributed Systems Principles and Paradigms 2nd edition》:作者: Tanenbaum, Andrew S. / Steen, Maarten van 出版社: Pearson 出版年: 2001-9-1 页数: 803 ISBN: 9780131217867 &#8617; C1 分布式系统概述什么是分布式系统定义：分布式系统是若干独立计算机的集合，它们对于用户来说就像一个系统 分布式系统中透明性的种类 透明性 描述 访问 隐藏数据表示形式以及访问方式的不同 位置 隐藏数据所在的位置 迁移 隐藏资源是否已移动到另一个位置 重定位 隐藏资源是否在使用中已移动到另一个位置 复制 隐藏资源是否已被复制 并发 隐藏资源是否由若干相互竞争的用户共享 故障 隐藏资源的故障和恢复 持久性 隐藏资源（软件）位于内存里或磁盘上 透明度：透明性受到的限制 必须将透明性与其他因素（如性能）结合起来考虑（如复制透明性中的复制更新） 分布式系统中的扩展技术有哪些 隐藏通信等待时间 异步通信 减少通信量 a 由服务器检查表单； b 由客户端检查表单 分布技术：分割组件，分散到系统中，如DNS和WWW 将DNS名字空间划分为区的例子 复制技术：多拷贝 复制：增加可用性，有助于负载均衡 缓存：在访问资源的客户周围制作资源备份 一致性问题 C2 体系结构客户端-服务器模型集中式 服务器：实现某个特定服务的进程 客户：向服务器请求服务的进程 客户端-服务器之间的一般交互：请求/回复 无连接的协议：高效，受传输故障的影响，适合局域网 基于连接的协议：性能相对较低，适合广域网 客户服务器应用程序通常组织为三个层次： 用户界面层：用户交互所需的一切 处理层：应用程序核心功能 数据层：操作数据或文件系统，保持一致性 客户端-服务器模型可能具有多层体系结构，可能的组织结构如下图a-e所示： 服务器可充当客户端角色，应用服务器向数据库服务器发出了请求，这里应用服务器作为客户端，如下图例中所示： C3 分布式进程管理进程和线程的比较 地址空间和其他资源（如打开文件）：进程间相互独立，同一进程的各线程间共享该进程地址空间和其他资源；某进程内的线程在其他进程不可见 通信：进程间通信通过IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信；需要进程同步和互斥手段的辅助，以保证数据的一致性 调度：线程上下文切换比进程上下文切换要快得多 线程是CPU调度单位；进程只作为其他资源分配单位 结论：多线程能提高性能；线程不像进程那样彼此隔离，并受到系统自动提供的保护，因此多线程应用程序开发需要付出更多努力 多线程服务器的优点 在某一线程阻塞时，其他线程可以继续工作 利用多处理器，并行工作 缩短IPC通信的时间 出于软件工程的考虑：例如 字处理程序（用户输入、拼写检查、语法检查、文档布局） 多线程技术不仅能够显著简化服务器代码，还能够使得应用并行技术来开发高性能的服务器变得更加容易，即使在单处理器系统上也是如此。多线程能够保留顺序处理的思路，使用阻塞性系统的系统调用，仍然能到达并行处理的目的。使用阻塞系统调用使编程更容易，并行处理能提高系统的性能。 简化服务器代码 提高并行性 提高服务器性能 保留顺序处理思路 使用阻塞系统调用使得编程更容易 代码迁移的动机有哪些代码迁移的定义：将程序或执行中的程序传递到其他计算机 动机： 实现负载均衡：将进程从负载重的系统迁移到负载轻的系统，从而改善整体性能 改善通信性能：交互密集的进程可迁移到同一个节点以减少通信开销；当进程要处理的数据量较大时，最好将进程迁移到数据所在的节点 可用性：需要长期运行的进程可能因为当前运行机器要关闭而需要迁移 使用特殊功能：可以充分利用特定节点上独有的硬件或软件功能 * 迁移与本地资源 进程对资源的绑定类型有哪些按标识符（URL）、按值和按类型 资源对机器的绑定类型有哪些未连接（数据文件）、附着连接（数据库）和紧固连接（本地设备） C4 分布式系统通信什么是远程过程调用？远程过程调用的步骤远程过程调用（Remote Procedure Call， RPC）是分布式系统通信处理的事实标准，实现消息传输的透明性 远程过程调用(Remote Procedure Call)RPC 是指本地程序调用位于其他机器上的进程，调用方通过消息的形式把参数传递到被调用方的进程，然后等待被调用方执行完后用消息的方式把结果传回调用方。 远程过程调用：当机器A上的进程调用B上的进程时，A上的调用进程被挂起，而B上的被调用进程开始执行。调用方可以通过使用参数将信息传送给被调用方，然后可以通过传回的结果得到信息。编程人员看不到任何消息传递过程。这种方法称为远程过程调用。 步骤： 客户过程以正常的方式调用客户存根 客户存根生成一个消息，然后调用本地操作系统 客户端操作系统将消息发送给远程操作系统 远程操作系统将消息交给服务器存根 服务器存根将参数提取出来，然后调用服务器 服务器执行要求的操作，操作完成后将结果返回给服务器存根 服务器存根将结果打包成一个消息，然后调用本地操作系统 服务器操作系统将含有结果的消息发送给客户端操作系统 客户端操作系统将消息交给客户存根 客户存根将结果从消息中提取出来，返回给调用它的客户过程 消息持久通信和暂时通信的区别？ 持久通信：通信双方不必保持运行 暂时通信：通信系统只在发送者和接收者运行时存储消息 消息同步通信和异步通信的区别？ 持久异步通信：提交消息后立即执行其他程序，如电子邮件 持久同步通信：提交消息后会被阻塞，直到消息已到达并存储在接收主机 能够判断消息通信的类型 上图中： a）持久异步通信 b）持久同步通信 c）暂时异步通信 d）基于接收的暂时同步通信 e）基于交付的暂时同步通信 f）基于响应的暂时同步通信 多播通信：反熵和Gossiping反熵 提供最终一致性：保证所有的副本最终是一致的 一个服务器可以是： 传染性的：持有愿意向其他服务器散布的更新 易感的：尚未更新的服务器 隔离的：已更新的服务器如果不愿意或不能扩散其更新 反熵传播模型：服务器P周期的随机选取一台服务器Q交换更新，方式包括： P只把自己的更新推入Q：较差的选择？ P只从Q拉出新的更新 P和Q互相发送更新 可以证明：如果初始只有一台服务器具有传染性，无论采用哪种形式，更新最终将被传播到所有服务器上；$O(log(N))$，N为系统节点数 Gossiping模型 思想： 如果服务器P刚刚因为数据项x而被更新，那么它联系任意一个其他服务器Q，并试图将更新推入Q 如果Q已经被其他服务器更新了，P可能会失去继续扩散的兴趣，变成隔离的（这种可能性是1/k） 快速传播更新的方法 但不能保证所有的服务器都被更新了 $s=e^{-(k+1)(1-s)}$,$k=3$时，s小于2%；$k=4$时，s小于0.7% 可以将gossiping和反熵模型结合 C5 命名系统给定实体的一个无结构的名称（如标识符）如何定位该实体？（移动实体定位的方法有哪些？） 广播和多播：广播适用于局域网，在广域网内变得低效；多播只发送给一组符合条件的主机，可进行多播实体的定位服务，可用于定位最近副本 转发指针：原理是：当实体从A移动到B时，它将后面留下一个指针，这个指针指向它在B中的新位置，这种方法主要优点是它很简便：一旦找到实体以后（比如使用传统的命名服务），客户就可以顺着转发指针形成的链来查找实体的当前地址。 基于起始位置的方法：原理是：每个移动主机都是用一个固定的IP地址，所有与该IP地址进行的通信一开始都被转发到移动主机的宿主代理（home agent）中。宿主代理位于局域网中，与包含在移动主机IP地址中的网络地址相对应。当一台移动主机转移到另一个网络中时，它会请求一个可以用来通信的临时地址。这种转交地址（care-of address）要在宿主代理中注册。 分层方法：具体细节在下一节中。 * 分层方法介绍 类似DNS 网络被划分为一组域 目录节点：记录域包含的实体 叶域的目录节点N记录实体E在域中的位置 更高一层域的目录节点N’记录实体E的位置，包含指向N的指针 这些节点构成一个目录节点树，顶级域的目录节点称为根（目录）节点，包含有全部的实体；根节点拥有每个实体的位置记录，其中每条位置记录都存储一个指向更底层子域目录节点的指针，该记录关联的实体当前就位于这里 实体可以拥有多个地址，比如它被复制了，就会出现这种情况，如果实体分别在叶域D1和D2中拥有地址，那么同时包含D1和D2的最小域的目录节点将有两个指针，每个指针都指向一个包含地址的子域，也就是下图中的效果（通用组织树） 描述分层方法中查找一实体的过程如下图所示， 希望定位实体E的客户指向它所在的叶域D的目录节点发送一个查找请求。 如果这个目录节点没有存储该实体的位置记录，那么就说明该实体不在D中。因此，这个节点会把请求转发给它的父节点。 注意，这里父节点代表一个比它的子域更大的域，如果父节点也没有E的位置记录，那么就会把该查找亲求转发给更高一层的域，以此类推。 如果节点M存储了E的位置记录，那么一旦请求到达M后，就可以知道E位于节点M代表的域dom（M）中。如下图所示，M存储了一条位置记录，其中包含一个指向其子域的指针。 然后，把请求转发给那个子域的目录节点，那个子域会依次进一步向树的下方转发请求，直到请求最终到达叶节点位置。存储在叶节点中的位置记录会包含E在哪一个叶域中的地址。 这样就可以把这个地址返回给发起请求的客户。 一个与分层定位服务有关的重要因素是，查找操作是在局部进行的。原则上，对实体的搜索实在一个以发出查找请求的客户为中心，逐步增大的环中进行的。每当查找请求被转发到更高一层的目录节点是，都会扩大搜索区域。在最差情况下，搜索会连续进行。直至请求到达根节点为止。由于根节点拥有所有实体的位置记录，所以此时可以简单地沿着一条向下的指针路线把请求转发给一个叶节点。 描述分层方法中插入一实体的过程更新操作以与查找类似的方式在局部进行，如下图所示。 假设实体E在叶域D中创建了一个副本，就需要插入这个副本的地址。插入操作从D的叶节点dir（D）开始，然后D会立即把插入请求转发给父节点。 父节点同样会转发插入请求，直到插入请求到达已经为E存储了位置记录的目录节点M为止。 然后，节点M会在E的位置记录中存储一个指针，该指针指向转发插入请求的那个子节点。此时，该子节点会建立一条关于E的位置记录，该位置记录中包含一个指针，指向转发请求的下一层节点。这个过程会连续进行，直至到达发起请求的叶节点为止。 最后那个叶节点会创建一条记录，这条记录包含实体在叶域中的位置。 也就是，插入请求转发到第一个知道实体E的节点；转发指向叶节点的指针所形成的链 刚才介绍的插入地址操作会导致一条从上到下建立的指针链，它从一个最底层的目录节点开始，该节点拥有实体E的位置记录。另一种是在向父节点发送插入请求之前创建一条位置记录。换句话说，就是从下往上建立指针链。后者的优点是地址会尽快变得可用。这样的话，即使父节点暂时无法到达，仍然可以在当前节点所在的域内查找实体的地址。 C6 同步Lamport时间戳算法的思想基于Lamport算法，一种逻辑时钟同步化算法的被称为向量时间戳的Lamport扩展算法 时间戳（Time-Stamping）的算法： 网络上的每个系统（站点）维护一个计数器，起时钟的作用 每个站点有一个数字型标识，消息的格式为$(m,T_i,i)$，m为消息内容，$T_i$为时间戳，i为站点标识 当系统发送消息时，将时钟加一 当系统j接收消息时，将它的时钟设为当前值和到达时间戳这两者的最大值加一 在每个站点，时间的排序遵循以下规则：对来自站点i的消息x和站点j的消息y，如果 $T_i&lt;T_j$或$T_i=T_j$，且$i&lt;j$，则说消息x早于消息y 哪个事件在实际上首先发生并不重要，重要的是所有进程对时间的发生顺序意见一致 例如下图中，消息 a 最早，接下来是消息 x，接下来是消息 b，最后是消息 j；可以看到消息 b 和消息 j 的时间戳是相同的，但是消息 b 来自站点P1，消息 j 来自站点P3，1&lt;3，因此所有站点都认同消息 b 早于消息 j 的结论。 类似的，在下图的例子中，消息a早于消息q 选举算法中Bully算法的思想当进程P注意到需要选举一个进程作协调者时： 向所有进程号比它高的进程发ELECTION消息 如果得不到任何进程的响应，进程P获胜，成为协调者 如果有进程号比它高的进程响应，该进程接管选举过程，进程P任务完成 当其他进程都放弃时，只剩一个进程时，该进程成为协调者 一个以前被中止的进程恢复后也有选举权 下图例子中： 进程4启动选举 进程5和进程6响应，接管选举，成为协调者 进程6响应进程5的消息，接管选举，进程6成为协调者，通知所有进程 选举算法中环算法的思想 不使用令牌 按进程号排序，每个进程都知道自己的后继者 当进程P注意到需要选举一个进程作协调者时; 就创建一条包含该进程号的ELECTION消息，发给后继进程 后继进程再将自己的进程号加入ELECTION消息，依此类推 最后回到进程P，它再发送一条COORDINATOR消息到环上，包含新选出的协调者进程（进程号最大者）和所有在线进程 具体过程如下图所示： 分布式死锁检测Chandy-Misra-Haas算法的思想 思想允许进程一次请求多个资源（加锁）而不是一次一个 通过允许多个请求同时进行使得事务的增长阶段加速 这使得一个进程可以同时等待两个或多个进程 例子当某个进程等待资源时，例如P0等待P1，将调用Chandy-Misra-Haas算法。生成一个探测消息发送给占用资源的进程。 消息由三个数组构成：阻塞的进程、发送消息的进程、接收消息的进程 例如，由P0到P1的初始消息包含三元组（0，0，1） 消息到达后，接受者检查以确认它自己是否也在等待其他进程。 若是，就更新消息，字段 1 保持不变，字段 2 改成当前进程号，字段 3 改为等待的进程号 然后消息接着被发送到等待的进程 若存在多个等待进程，就要发送多个不同的消息 不论资源在本地还是在远程，该算法一直继续下去。 图中，（0，2，3），（0，4，6），（0，5，7）和（0，8，0）都是远程消息。 若消息转了一圈又回到了最初的发送者，即字段1所列的进程，就说明存在一个有死锁的环路系统。 C7 一致性和复制复制的目的和代价 可靠性 性能 服务器数量扩展 地理区域扩展 代价：一致性 网络通信开销 强一致性要求的原子操作很难快速完成 解决办法：放宽一致性方面的限制，放款程度取决于复制数据的访问和更新模式以及数据的用途 能区分是否符合严格一致性、顺序一致性、因果一致性和FIFO一致性 严格一致性（Strict Consistency）： 任何对数据项X的读操作将返回最近一次对X进行写操作的值 对所有进程来说，所有写操作都是瞬间可见的，系统维护着一个绝对的全局时间顺序 上图中：a) 严格的一致性存储；b)非严格的一致性存储 顺序一致性 顺序一致性对存储器的限制比严格一致性要弱一些，要满足以下的条件： 每个进程的内部操作顺序是确定不变的 加入所有的进程都对某一个存储单元执行操作，那么，它们的操作顺序是确定的，即任一进程都可以感知到这些数据同样的操作顺序 上图中：a) 顺序一致的数据存储；b) 非顺序一致的数据存储 因果一致性（Casual Consistency） 所有进程必须以相同的顺序看到具有潜在因果关系的写操作 不同机器上的进程可以以不同的顺序看到并发的写操作 上图是，因果一致性存储允许的，但顺序和严格一致性存储不允许的顺序 上图中：a) 违背因果一致性的时间存储顺序；b) 符合因果一致性的时间存储顺序 FIFO一致性（FIFO Consistency） FIFO一致性模型是在因果一致性模型上的进一步弱化，它满足下面的条件： 由某一个进程完成的写操作可以被其他所有的进程按照顺序感知到，而从不同进程中来的写操作对不同的进程可以有不同的顺序。 下图是一个符合FIFO一致性的时间存储顺序，b一定在c之前 FIFO一致性与顺序一致性的区别： 顺序一致性：尽管语句的执行顺序是非确定的，但所有的进程对顺序达成一致。 FIFO一致性：各个进程不需要达成一致，不同进程可以以不同的顺序看到 一致性总结 | 一致性（Consistency） | 描述（Description） || ——————————- | —————————————————————————————— || 严格 | 所有共享访问按绝对时间排序 || 线性化 | 所有进程以相同顺序看到所有的共享访问。而且，访问时根据全局时间戳排序的 || 顺序 | 所有进程以相同顺序看到所有的共享访问。访问不是根据时间排序的 || 因果 | 所有进程以相同顺序看到因果相关的共享访问 || FIFO | 所有进程以不同进程提出写操作的顺序相互看到写操作。来自不同进程的写操作可以不必总是以相同的顺序出现 | 能区分是否符合单调读、单调写、写后读和读后写 单调读（Monotonic Reads） 定义：如果一个进程读取数据项x的值，那么该进程对x执行的任何后续读操作将总是得到第一次读取的那个值或更新的值 上图中描述了，进程P对同一数据存储的两个不同本地副本执行的读操作；L1，L2表示数据存储的两个不同的本地副本，水平轴表示时间。WS（x1；x2）表示WS（x1）的操作已在L2更新完毕。 图（a）表示保证单调读一致性的情况。图（b）表示不保证单调读一致性的情况。 单调写（Monotonic Writes） 定义：一个进程对数据项x执行的写操作必须在该进程对x执行的任何后续写操作之前完成。 上图中描述了，进程P对同一数据存储的两个不同本地副本执行的写操作；图（a）为提供单调写一致性的数据存储；图（b）为不提供单调写一致性的顺序存储。 写后读（读写一致性，Read Your Writes） 定义：一个进程对数据项x执行的写操作总会被该进程对x执行的任何后续读操作看见 也就是说，一个写操作总是在同一进程执行的后续读操作之前完成，而不管这个后续读操作发生在什么位置。 上图（a）中描述了一个提供写后读一致性的数据存储；图（a）（b）非常相像，只是这里的一致性是通过进程P执行的最后一次写操作确定的，而不是通过进程P的最后一次读操作确定；图（a）为提供写后读一致性的数据存储；图（b）为不提供写后读一致性的顺序存储。 读后写（写读一致性， Writes Follows Reads） 定义：同一个进程对数据项x执行的读操作之后的写操作，保证发生在与x读取之相同或更新的值上。 也就是说，进程对数据项x所执行的任何后续写操作都会在x的副本上执行，而该副本是用该进程最近读取的值更新的。 上图中，图（a）为提供读后写一致性的数据存储；图（b）为不提供读后写一致性的顺序存储。 基于主备份的协议：远程写协议、本地写协议 基于主备份的协议：每个数据x都有一个关联的主备份，负责协调x的写操作，根据主备份的位置分为：远程写协议，本地写协议 远程写协议 基于主备份的远程写协议，所有读操作和写操作都被转发到一个固定的服务器上 允许进程在本地可用的副本上执行读操作，但必须向一个固定的主拷贝上转发写操作 提供实现顺序一致性的直接方法 本地写协议 基于主备份的本地写协议，其中一个单一的拷贝在多个进程间移动 保证一致性 需要跟踪数据项的当前位置：广播、转发指针、基于原始位置的方法和层次定位服务。 多个连续的写操作可在本地进行，而读操作的进程还可以访问它们的本地拷贝 支持离线操作 主机备份协议，其中主备份移动到要执行更新的进程那里 复制的写协议：主动复制、基于法定数目的协议 复制的写协议：写操作可以在多个副本上执行 主动复制 写操作可以在多个副本上执行，每个副本对应一个进程，该进程执行更新操作 写操作导致更新传播 操作需要在各地按相同顺序进行： 时间戳(Lamport) 定序器 基于法定数目（多数表决）的协议 要更新一个文件，必须先联系至少半数加一个服务器，并得到它们同意后执行更新，修改文件后这些服务器上的文件将得到一个新的版本号；要读取一个文件，必须联系至少半数加一个服务器，请求它们返回该文件关联的版本号，若版本号一致则该版本为最新版本，因为剩余服务器的个数不够半数以上，试图只更新剩余服务器的请求将会失败。 Gifford方法：客户在读写一个复制的数据时，先向多个服务器提出请求，获得许可；读团体$N_R$，写团体$N_W$，$N$个副本；满足$N_R+N_W&gt;N,且 N_W&gt;N/2$ Gifford方法中，上述第一个条件用于防止读写操作冲突；而第二个限制条件用于防止读读操作冲突。只有在适当个数的服务器同意参与文件的读写后，客户才能读或写该文件。 下图中的三个实例：(a) 读集合和写集合的正确选择；(b)可能导致写写冲突的读集合和写集合，例如两个写集合{A, B, C, E, F, G}和{D, H, I, J, K, L}就会发生写写冲突；(c)读集合和写集合的正确选择，ROWA（read one, write all）。 C8 容错性什么是容错性 容错意味着系统即使发生故障也能提供服务 容错与可靠性相联系，包含以下需求： 可用性（Availability）：任何给定的时刻都能及时工作 可靠性（Reliability）：系统可以无故障地持续运行 安全性（Safety）系统偶然出现故障能正常操作而不会造成任何灾难 可维护性（Maintainability）发生故障的系统被恢复的难易程度 拜占庭将军问题这里被用于描述分布式系统中的进程故障，故障进程无法发送信息或发出干扰信息，影响其他进程的正常工作，导致系统一致性出现问题。 在拜占庭将军问题中，叛将代表故障进程，忠将代表正常进程。 Lamport的论文中提到的算法指出：如果存在k个叛将（故障进程），那么至少需要总共N=3k+1个将军（进程），才能最终达到一致的行动方案。 例如，下图中，有三个忠诚将军和一个叛将，叛将（故障进程）的代号是3，其余是忠诚将军（无故障进程），也就是k=1，N=4；简单来说，图（a）为将军宣布他们的兵力，图（b）为在（a）基础上每个将军收到的兵力组成的向量，图（c）为每个将军收到的向量；更具体地说，算法分为四步进行。 如图（a）；每个无故障进程 i 使用可靠单播给其他每个进程发送 vi ，这里假设 vi=i；故障进程则可能发送其他内容，且故障进程可能给不同进程发送不同的值，例如上图中故障进程3给其他进程1，2，4分别发送x，y，z。 如图（b）；每个进程把第一步收到的结果组织成向量形式。 如图（c）；把组织好的向量发送给其他进程，此时，每个进程将得到来自其他三个进程的三个向量；由于进程3是故障的，产生了$a-l$共12个值。 每个进程检查每个接收到向量中的第 i 个元素。如果存在占多数的值，那就将占多数的值放置到结果向量中；如果不存在占多数的值，那么结果向量的相应元素就标记为未知（UNKNOWN）。从（c）中可以看出，1、2、4都与v1、v2、v4的值一致，是正确的结果。从这些进程得出的结论无法确定v3，但也是不相关的。拜占庭协定的目标是一致性意见只与无故障进程的值有关。 下图中，有两个忠诚将军和一个叛将，叛将（故障进程）的代号是3，其余是忠诚将军（无故障进程），也就是k=1，N=3；在图（c）中，无故障进程的向量中无法看到元素1、2和3占大多数的情况，因此都标记为未知，该算法不能产生协定。 一些网络上的参考资料对拜占庭将军问题做了更加具体的说明。 拜占庭将军问题(The Byzantine Generals Problem)提供了对分布式共识问题的一种情景化描述, 由Leslie Lamport等人在1982年首次发表. 论文同时提供了两种解决拜占庭将军问题的算法： 口信消息型解决方案(A solution with oral message); 签名消息型解决方案(A solution with signed message). 本文之后将详细讲述这两种算法. 事实上, 拜占庭将军问题是分布式系统领域最复杂的容错模型, 它描述了如何在存在恶意行为(如消息篡改或伪造)的情况下使分布式系统达成一致. 是我们理解分布式一致性协议和算法的重要基础. 参考： 如何理解拜占庭将军问题？ 拜占庭将军问题 (The Byzantine Generals Problem) 拜占庭将军问题 (The Byzantine Generals Problem) 拜占庭将军问题 拜占庭问题与算法 什么叫原子多播 可实现存在进程失败情况下的可靠多播 原子多播： 消息要么发送给所有进程，要么一个也不发送 通常需要所有的消息都按相同的顺序发送给所有的进程 分布式系统中的复制数据库 原子多播确保没有故障的进程对数据库保持一致；当一个副本从故障恢复并重新加入组时，原子多播强制它与其他组成员保持一致 原子多播=虚拟同步+消息排序 分布式提交-两阶段提交的思想简单、使用、可靠，成为事实上的工业标准。 在两阶段提交（two-phase commit protocol, 2PC）协议中，将提交分为两个阶段 第一阶段（表决阶段）：事务的协调者询问各个参与者是否可以提交，此时，各个参与者将回答消息发送给协调者。协调者根据收到的消息，看是否可以真正提交。 第二阶段（完成阶段）：如果可以提交，则通知各参与者立即执行提交，否则，通知它们终止此事务。 下图中，图（a）为2PC中的协调者的有限状态机；图（b）为2PC中的参与者的有限状态机。 参与者一旦投票，则失去自主能力，必须等待协调者的最终决定，可能造成阻塞；可能的阻塞状态有： 参与者在INIT状态等待协调者的VOTE_REQUEST消息 协调者在WAIT状态等待来自每个参与者的表决 参与者在READY状态等待协调者发送的全局表决消息 下图中，列出了参与者P在READY状态下与另一个参与者Q联系时采取的行动。 当所有运行的参与者都处于READY状态时，尽管都已同意提交，但可能有崩溃的参与者（不一定同意提交），因而无法做出决定（即使选举出新的协调者），只能等待原协调者恢复。 C9 分布式安全什么是机密性和完整性？ 机密性：系统将信息只向授权用户公开 完整性：对系统资源的更改只能以授权方式进行 对称加密系统和公钥系统的区别？ 对称加密系统：加密与解密密钥相同，即$P=D_K(E_K(P))$ 非对称加密系统：加密与解密密钥不同（一个公开、一个保密），但构成唯一的一对，即$P=D_{KD}(E_{KE}(P))$，也称为公钥系统 * 相关的资料 什么是安全通道？安全通道：使客户与服务器之间的通信保持安全，免受对消息的窃听、修改和伪造的攻击。 阐述基于共享密钥的身份验证的思想。质询-响应协议：一方向另一方质询一个响应，只有对方知道共享密钥时才能给予正确的响应。 下图的过程为： A希望联系B B发送质询RB A返回基于共享密钥加密RB后的信息$K_{A,B}(R_B)$ 接下来A发送质询RA B返回基于共享密钥加密RA后的信息$K_{A,B}(R_A)$ 若使用三个消息代替五个，则可能会出现错误，存在被反射攻击的风险 原因：协议的双方在两个不同方向都使用相同的质询 解决：协议的双方永远使用不同的质询 下图描述了反射攻击的过程，攻击者C通过建立两条信道，并将第二次质询的结果，作为第一次被质询的答案返回给B，假装C知道$K_{A,B}$以达到欺骗B冒充A的目的。 阐述使用密钥发布中心的身份验证的思想。基于共享密钥的身份验证可能存在扩展性问题：N台主机，需要$N*(N-1)/2$个密钥 使用密钥分发中心(Key Distribution Center, KDC)，系统中只需要管理N个密钥 KDC与每台主机共享一个密钥；下图展现了向通信的两台主机分发一个密钥的过程： 首先A告诉KDC期望与B通信; KDC返回分别使用A与KDC之间的密钥、B与KDC之间的密钥加密后的A与B之间的密钥，即$K_{A,KDC}(K_{A,B}), K_{B,KDC}(K_{A,B})$，将上述信息分别分发给A，B；这样就可以通信了 但上图中的方法存在缺点，A可能希望在B接收到来自KDC的共享密钥之前就开始与B建立安全通道，且需要KDC通知B进入通信中。为了解决这些问题，出现了下图中的协议； KDC返回分别使用A与KDC之间的密钥、B与KDC之间的密钥加密后的A与B之间的密钥，即$K_{A,KDC}(K_{A,B}), K_{B,KDC}(K_{A,B})$，将上述信息都分发给A，最后由A转发给B。$K_{B,KDC}(K_{A,B})$被称为票据，显然，只有B能够使用票据，因为加密票据的密钥只有KDC与B知道。 阐述使用公钥加密的身份验证的思想。使用公钥加密的审问认证的过程如下图所示，假定A、B都拥有彼此的公钥。 具体过程为： A向B发送一个是使用B的公钥$K_B^+$加密的质询RA，显然只有拥有B的私钥的人才能够解密该信息 B接收到信息后，会返回解密过后的质询RA、对A的质询RB、用于更进一步通信的会话密钥$K_{A,B}$；上述返回的信息均使用A的公钥$K_A^+$加密 最后，A返回一个使用会话密钥$K_{A,B}$对质询RB加密后的信息给B，证明确实是AB之间在交谈。这样连接就建立完毕，可以进行后续的对话 使用公钥加密对消息进行数字签名的思想。数字签名： 如果消息签名检验为真，发送者不能否认消息签名这一事实 消息与其签名的唯一关联防止了对消息进行修改而未发现的可能 使用公钥加密对消息进行数字签名 下图描述了使用公钥加密对消息进行数字签名的过程。 首先A，对原始消息m使用A的私钥$K_A^-$加密，作为签名，接下来为了使消息保密发出，使用B的公钥$K_B^+$进行第二轮加密，之后向B发出。 B收到消息后，首先使用B的私钥$K_B^-$解密，接下来使用A的公钥$K_A^+$解密，最后得到原始的信息；如果保证公钥确实属于A，那么解密m的签名版本以及成功地与m进行比较只能意味着该消息来自A。A受到防止B对m进行任何恶意修改的保护，因为B必须一直证明m的修改版本也是由A签名的。换句话说，经解密的消息本身在本质上从来不能作为证据。 但是上述方法还存在问题。比如： A可以声称其私钥在消息发送前被盗了 A可以改变其私钥 使用私钥加密整个消息的开销可能会过大；可使用消息摘要解决，消息摘要是固定长度的位串h=H(m), m是任意长度的消息，H是加密散列函数 下图描述了使用消息摘要对消息进行数字签名的过程 上图中，消息摘要使用A的私钥加密后发送，消息使用明文发送，若需要保密可使用B的公钥加密后发送；B得到消息与加密后的摘要后，单独计算消息得到所接收消息的摘要，并使用A的公钥解密收到的摘要，若计算出的摘要与解密后的摘要相匹配，则证明该消息是由A签名的。 Diffie-Hellman 建立共享密钥的原理。原理： 首先A和B双方约定两个大整数n和g，其中1&lt;g&lt;n;这两个整数无需保密，然后执行下面的过程： A随机选择一个大整数x（保密），并计算$X=g^x\\mod n$ B随机选择一个大整数y（保密），并计算$Y=g^y\\mod n$ A把X发送给B，B把Y发送给A A计算K=Y^x\\mod n = (g^y\\mod n)^x\\mod n=g^{xy}\\mod n B计算K=X^y\\mod n=(g^x \\mod n)^y \\mod n=g^{xy}\\mod n K即是共享的密钥 监听者在网络上只能监听到X和Y，但无法通过X、Y计算出x和y，因此无法计算出K 下图描述了上述原理中的过程： 权能和委派。权能权能是对于指定资源的一种不可伪造的数据结构，它确切指定它的拥有者关于该资源的访问权限。 存在不同的权能实现方式，这里讨论的是Amoeba操作系统中所使用的实现方式。check字段用于是权能不可伪造；rights为权限位，rights在每种对象类型中的意义是不同的 为了调用一个对象的操作，客户必须将权能传递给服务器检查 服务器创建对象时，客户得到是所有者权能（全1），check字段是随机选择的，同时存储在权能和服务器的一个表中 客户可以从一个所有者权能生成一个受限权能，并发送给另一进程 委派委派：将某些访问权限从一个进程传递给另一个进程 例如： A可以构造证书，将权限R给证书的持有者，如B； A授权R给B，需要向B传递两部分内容，被称为代理，分别是证书，和证书中公钥$S^+_{proxy}$对应的私钥$S^-_{proxy}$。用于委派的一般代理结构如下所示： 证书由三部分构成，分别是权限R，公钥$S^+_{proxy}$和对证书的签名$sig(A,{R,S^+_{proxy}})$；证书可以使用明文传递。 公钥$S^+_{proxy}$对应的私钥$S^-_{proxy}$需要加密传递，用于检验B确实是被授权了。 使用代理来委派和证实访问的所有权的过程如下图所示： 具体过程为： 消息1传递委派代理给B，包括明文传递的由A签名的含有权限R和公钥$S^+_{proxy}$和密文传递的证书对应的私钥$S^-_{proxy}$ 消息2为B希望使用A赋予的权限R，在服务器执行操作 消息3为服务器向B确认B是否为权限的合法所有者，即使用证书中的公钥加密一个信息N对B质询 消息4为B返回使用私钥解密后的结果给服务器，证明B确实是该证书的合法持有者 显然，B还可以在A不知道的情况下，将权限赋予给其他人。 C10 分布式文件系统NFS的共享预约共享预约是一种锁定文件的隐含方法。共享预约完全独立于锁定，可用于在基于Windows的系统上实现NFS。 客户打开文件时，需要指定所需的访问类型（即READ、WRITE或BOTH），以及服务器应该拒绝其他客户的访问类型。如果服务器不能满足客户的需求，那么该客户的open操作会失败。 下图中确切地表示了一个新客户试图打开一个已被另一个客户成功打开的文件时的情况。对于一个已经打开的文件，使用两个不同的状态变量加以区分。访问状态表明当前客户目前如何访问该文件。拒绝状态表明新客户不要内需进行哪些访问。 上图中（a）表示给定一个文件的当前拒绝状态的情况下，客户试图请求以指定的访问类型打开此文件时所发生的事情；同样，（b）表示试图打开一个当前正被另一个客户访问的文件而所请求的访问类型不被该客户允许的情况。 NFS服务器的重复请求高速缓存 NFS的底层RPC不能保证可靠性，而且缺乏对重复请求的检测 NFS服务器提供重复请求高速缓存解决：XID事务处理标识符 具体描述为：每个来自客户的RPC请求都有一个唯一的XID。当RPC到来时，服务器缓存该XID。只要服务器还没有发出响应。就说明正在处理这个RPC请求。当服务器处理某个请求后，也缓存该请求的关联响应，与XID相联系，再将响应返回给客户。常见下图中三种情况： （a）客户端启动计时器，超时后客户仍未收到响应，因此使用原XID重发请求，若服务器收到了第一次请求但还没处理完成，则忽略第二次重发的请求 （b）服务器在返回响应后，收到了客户端的第二次请求，若返回响应的时间和收到第二次请求的时间接近，则忽略第二次请求 （c）服务器返回的响应丢失，且在相距应答发出后较远的时间收到了客户端发出的第二（或大于二）次请求，则重发该XID对应的响应结果 Coda的回叫（回调）承诺客户端缓存的重要性：可扩展性、容错性 Coda高速缓存了整个文件 回叫承诺：服务器记录哪些客户在本地缓存了文件的拷贝，如果文件被客户更改，会通知服务器，服务器会向其他客户发送无效化消息，（这种消息被称为回叫中断，也就是服务器废弃回叫承诺，这是因为服务器随后会将废弃它为刚刚向其发送了无效消息的客户保存的回叫承诺）如果客户在服务器上有未废弃的回叫承诺，它就可以安全地在本地访问文件。如下图中所示： 具体为当客户A开始会话$S_A$时，服务器会记录一个回叫承诺。同样，B开始会话$S_B$时也是如此。不过，当B关闭会话$S_B$时，服务器向客户A发送回叫终端，从而终端了它对回叫客户A的承诺。注意：由于Coda的事务处理语义，当客户A关闭会话$S_A$时，不会发生任何特殊的事情，整个关闭操作就像所预期的那样被简单地接收。 因此，当A随后要打开会话$S_A’$时，它会发现f本地的副本是无效的，所以它必须从服务器获取最新的版本。另一方面，当B开始会话$S_B’$是，它会注意到服务器仍有一个未被废弃的回叫承诺，该承诺意味着B可简单地重用从会话$S_B$获得的本地副本。 Coda的储藏技术 VSG（Volume Storage Group）是一个保存同一个复制卷的服务器集合。 可用的VSG成员叫做AVSG（Available VSG members）。 Coda使用ROWA（Read One, Write ALL）来维护复制卷的一致性 使用版本记录方案检测不一致性 下图描述了对于同一个复制文件，具有两个不同的AVSG的客户 Coda 允许客户在断开连接时（ASVG为空）的继续操作，基于本地备份，再次连接后回传服务器。基于事实：两个进程打开相同文件进行写操作很罕见。使用储藏技术（hoarding）。 也就是，为了成功地完成断开连接操作，需要解决的问题时确保客户缓存包含连接断开期间将访问的那些文件。如果采用简单的缓存方法，可以证明客户可能由于缺少必要的文件而不能继续执行。预先使用适当的文件填充高速缓存称为储藏。 下图描述了对于一个卷，Coda客户的状态转换图： END2023.3.2","categories":[{"name":"课程","slug":"课程","permalink":"/categories/课程/"}],"tags":[{"name":"课程","slug":"课程","permalink":"/tags/课程/"},{"name":"高级操作系统","slug":"高级操作系统","permalink":"/tags/高级操作系统/"},{"name":"分布式","slug":"分布式","permalink":"/tags/分布式/"}],"keywords":[{"name":"课程","slug":"课程","permalink":"/categories/课程/"}]},{"title":"2022秋学期-高级操作系统期末整理","slug":"2022秋学期-高级操作系统期末整理","date":"2023-02-25T08:07:33.000Z","updated":"2023-03-01T13:02:37.279Z","comments":true,"path":"2023/02/25/2022秋学期-高级操作系统期末整理/","link":"","permalink":"/2023/02/25/2022秋学期-高级操作系统期末整理/","excerpt":"","text":"2022秋学期 高级操作系统期末整理C0 引言本文内容来自于对高级操作系统课程资料的整理； 本文所涉及的课程指东北某沿海高校，计算机学院硕士生必修课“高级操作系统”，课程资料包括课程PPT、教材《分布式系统原理与范型 第二版》1、《Distributed Systems Principles and Paradigms 2nd edition》2，以及网络资料。 1. 《分布式系统原理与范型 第二版》 作者: （美）特尼博姆 出版社: 清华大学出版社 原作名: Distributed Systems: Principles and Paradigms 译者: 辛春生 :出版年: 2008-6-1 页数: 490 ISBN: 978730217279 &#8617; 2. 《Distributed Systems Principles and Paradigms 2nd edition》:作者: Tanenbaum, Andrew S. / Steen, Maarten van 出版社: Pearson 出版年: 2001-9-1 页数: 803 ISBN: 9780131217867 &#8617; C1 分布式系统概述什么是分布式系统定义：分布式系统是若干独立计算机的集合，它们对于用户来说就像一个系统 分布式系统中透明性的种类 透明性 描述 访问 隐藏数据表示形式以及访问方式的不同 位置 隐藏数据所在的位置 迁移 隐藏资源是否已移动到另一个位置 重定位 隐藏资源是否在使用中已移动到另一个位置 复制 隐藏资源是否已被复制 并发 隐藏资源是否由若干相互竞争的用户共享 故障 隐藏资源的故障和恢复 持久性 隐藏资源（软件）位于内存里或磁盘上 透明度：透明性受到的限制 必须将透明性与其他因素（如性能）结合起来考虑（如复制透明性中的复制更新） 分布式系统中的扩展技术有哪些 隐藏通信等待时间 异步通信 减少通信量 a 由服务器检查表单； b 由客户端检查表单 分布技术：分割组件，分散到系统中，如DNS和WWW 将DNS名字空间划分为区的例子 复制技术：多拷贝 复制：增加可用性，有助于负载均衡 缓存：在访问资源的客户周围制作资源备份 一致性问题 C2 体系结构客户端-服务器模型集中式 服务器：实现某个特定服务的进程 客户：向服务器请求服务的进程 客户端-服务器之间的一般交互：请求/回复 无连接的协议：高效，受传输故障的影响，适合局域网 基于连接的协议：性能相对较低，适合广域网 客户服务器应用程序通常组织为三个层次： 用户界面层：用户交互所需的一切 处理层：应用程序核心功能 数据层：操作数据或文件系统，保持一致性 客户端-服务器模型可能具有多层体系结构，可能的组织结构如下图a-e所示： 服务器可充当客户端角色，应用服务器向数据库服务器发出了请求，这里应用服务器作为客户端，如下图例中所示： * 非集中式体系结构 垂直分布式：按照逻辑把不同的组件放在不同的机器上 水平分布式：客户或服务按照在物理上被分割成逻辑上相同的几部分，如：点对点系统 * 混合体系结构-协作分布式系统协作分布式系统：以C/S方式启动，一旦节点加入，则以完全非集中式协作，如：BitTorrent（BT） BT 下载网络有三个关键静态组件： 跟踪器（Tracker）：Tracker跟踪器是一个中央服务器，它主要跟踪系统中所有的参与节点，收集和统计这些节点的状态，帮助参与节点间互相发现并进行文件块的交换 种子节点（Seed）：Seed种子节点是指拥有完整文件的节点，提供上载服务 下载节点（Downloader）：相对于Seed的节点称为下载节点，一个下载节点完成下载后，可以成为种子节点。 BT的体系结构如下图所示： BT的动态流程为： 第一个用户通过BT工具制作要共享的Torrent文件（Torrent文件包含共享文件的下载信息）并发布此Torrent到WWW（网络）中 其他用户从WEB服务器上下载此Torrent文件并通过节点跟踪器协议（如TrackerHTTP）去访问Tracker跟踪器。参与到此Torrent网络中 Tracker跟踪器接收到一个新加入节点的下载请求后，随机选择部分此Torrent网络中的节点，发送给新加入者作为邻居节点，并记录此新节点 新加入节点通过一定的算法同邻居节点连接进行文件的下载和上载，直到文件下载完成。这一过程会根据一定的策略重复。如果继续上载，Tracker服务器将此节点看作种子节点 所有参与的节点将周期地报告自己的状态和进程给Tracker跟踪器 BT涉及的关键技术有： BT文件发布系统采用争锋相对（Tit_for_Tat）的方法发来达到帕累托（Pareto）有效，与当前其他的P2P技术相比，它达到了更高层次的鲁棒性和资源利用 帕累托最优：指资源配置已达到这样一种境地，即任何重新改编资源配置的方式，都不可能使一部分人在没有其他人受损的情况下受益 最少优先原则：对一个下载者来说，在选择下一个被下载的片段时，通常选择的是它的Peers（指邻居下载者）所拥有的最少的那个片段，也就是所谓的”最少优先“ C3 分布式进程管理进程和线程的比较 地址空间和其他资源（如打开文件）：进程间相互独立，同一进程的各线程间共享该进程地址空间和其他资源；某进程内的线程在其他进程不可见 通信：进程间通信通过IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信；需要进程同步和互斥手段的辅助，以保证数据的一致性 调度：线程上下文切换比进程上下文切换要快得多 线程是CPU调度单位；进程只作为其他资源分配单位 结论：多线程能提高性能；线程不像进程那样彼此隔离，并受到系统自动提供的保护，因此多线程应用程序开发需要付出更多努力 * 相关的资料 进程的定义：执行中的程序，进程控制块（PCB）；包含的状态如下： 线程：CPU调度单位；进程只作为其他资源分配单位 未引入线程前的进程是：资源分配单位（存储器、文件）和CPU调度（分配）的单位 线程只拥有必不可少的资源，如：线程状态、寄存器上下文和栈 线程同样具有就绪、阻塞和执行三种基本状态 进程的终止将导致它包含的所有线程的终止 线程的优点：减少并发执行的时间和空间开销（线程的创建、退出和调度），因此容许在系统中建立更多的线程来提高并发程度 线程的创建时间比进程短 线程的终止时间比进程短 同进程内的线程切换时间比进程短 由于同进程内线程共享内存和文件资源，可直接进行不通过内核的通信 进程创建的时间 线程创建的时间 多线程服务器的优点 在某一线程阻塞时，其他线程可以继续工作 利用多处理器，并行工作 缩短IPC通信的时间 出于软件工程的考虑：例如 字处理程序（用户输入、拼写检查、语法检查、文档布局） 多线程技术不仅能够显著简化服务器代码，还能够使得应用并行技术来开发高性能的服务器变得更加容易，即使在单处理器系统上也是如此。多线程能够保留顺序处理的思路，使用阻塞性系统的系统调用，仍然能到达并行处理的目的。使用阻塞系统调用使编程更容易，并行处理能提高系统的性能。 简化服务器代码 提高并行性 提高服务器性能 保留顺序处理思路 使用阻塞系统调用使得编程更容易 代码迁移的动机有哪些代码迁移的定义：将程序或执行中的程序传递到其他计算机 动机： 实现负载均衡：将进程从负载重的系统迁移到负载轻的系统，从而改善整体性能 改善通信性能：交互密集的进程可迁移到同一个节点以减少通信开销；当进程要处理的数据量较大时，最好将进程迁移到数据所在的节点 可用性：需要长期运行的进程可能因为当前运行机器要关闭而需要迁移 使用特殊功能：可以充分利用特定节点上独有的硬件或软件功能 * 迁移与本地资源 进程对资源的绑定类型有哪些按标识符（URL）、按值和按类型 资源对机器的绑定类型有哪些未连接（数据文件）、附着连接（数据库）和紧固连接（本地设备） C4 分布式系统通信什么是远程过程调用？远程过程调用的步骤远程过程调用（Remote Procedure Call， RPC）是分布式系统通信处理的事实标准，实现消息传输的透明性 远程过程调用(Remote Procedure Call)RPC 是指本地程序调用位于其他机器上的进程，调用方通过消息的形式把参数传递到被调用方的进程，然后等待被调用方执行完后用消息的方式把结果传回调用方。 远程过程调用：当机器A上的进程调用B上的进程时，A上的调用进程被挂起，而B上的被调用进程开始执行。调用方可以通过使用参数将信息传送给被调用方，然后可以通过传回的结果得到信息。编程人员看不到任何消息传递过程。这种方法称为远程过程调用。 步骤： 客户过程以正常的方式调用客户存根 客户存根生成一个消息，然后调用本地操作系统 客户端操作系统将消息发送给远程操作系统 远程操作系统将消息交给服务器存根 服务器存根将参数提取出来，然后调用服务器 服务器执行要求的操作，操作完成后将结果返回给服务器存根 服务器存根将结果打包成一个消息，然后调用本地操作系统 服务器操作系统将含有结果的消息发送给客户端操作系统 客户端操作系统将消息交给客户存根 客户存根将结果从消息中提取出来，返回给调用它的客户过程 * 相关的资料 常规过程调用 客户存根和服务器存根 参数传递 消息持久通信和暂时通信的区别？ 持久通信：通信双方不必保持运行 暂时通信：通信系统只在发送者和接收者运行时存储消息 驿马快递时代使用的就是持久通信 消息同步通信和异步通信的区别？下图中： a）持久异步通信：提交消息后立即执行其他程序，如电子邮件 b）持久同步通信：提交消息后会被阻塞，直到消息已到达并存储在接收主机 能够判断消息通信的类型下图中： a）持久异步通信 b）持久同步通信 下图中： c）暂时异步通信 d）基于接收的暂时同步通信 下图中： e）基于交付的暂时同步通信 f）基于响应的暂时同步通信 多播通信：反熵和Gossiping基于gossiping的数据通信 Epidemic协议使用本地信息在大型节点集中快速地传播信息 提供最终一致性：保证所有的副本最终是一致的 一个服务器可以是： 传染性的：持有愿意向其他服务器散布的更新 易感的：尚未更新的服务器 隔离的：已更新的服务器如果不愿意或不能扩散其更新 反熵传播模型：服务器P周期的随机选取一台服务器Q交换更新，方式包括： P只把自己的更新推入Q：较差的选择？ P只从Q拉出新的更新 P和Q互相发送更新 可以证明：如果初始只有一台服务器具有传染性，无论采用哪种形式，更新最终将被传播到所有服务器上；$O(log(N))$，N为系统节点数 Gossiping模型 思想： 如果服务器P刚刚因为数据项x而被更新，那么它联系任意一个其他服务器Q，并试图将更新推入Q 如果Q已经被其他服务器更新了，P可能会失去继续扩散的兴趣，变成隔离的（这种可能性是1/k） 快速传播更新的方法 但不能保证所有的服务器都被更新了 $s=e^{-(k+1)(1-s)}$,$k=3$时，s小于2%；$k=4$时，s小于0.7% 可以将gossiping和反熵模型结合 C5 命名系统描述实体定位的方法有哪些？（名称、标识符和地址） 名称：有位或字符串组成的串，用来指向一个实体 一个实体的访问点的地址称为该实体的地址：特定的服务器的地址：IP地址+端口 标识符：具有以下属性的名称： 一个标识符最多指向一个实体 每个实体最多由一个标识符指向 一个标识符始终指向一个实体 使用位串来表示 易于理解的名称：为用户指定，字符串表示 * 给定实体的一个无结构的名称（如标识符）如何定位该实体？（移动实体定位的方法有哪些？） 简单方法 广播和多播 广播适用于局域网，在广域网内变得低效；多播只发送给一组符合条件的主机，可进行多播实体的定位服务，可用于定位最近副本 转发指针 原理是：当实体从A移动到B时，它将后面留下一个指针，这个指针指向它在B中的新位置，这种方法主要优点是它很简便：一旦找到实体以后（比如使用传统的命名服务），客户就可以顺着转发指针形成的链来查找实体的当前地址。 基于起始位置的方法 原理是：每个移动主机都是用一个固定的IP地址，所有与该IP地址进行的通信一开始都被转发到移动主机的宿主代理（home agent）中。宿主代理位于局域网中，与包含在移动主机IP地址中的网络地址相对应。当一台移动主机转移到另一个网络中时，它会请求一个可以用来通信的临时地址。这种转交地址（care-of address）要在宿主代理中注册。 分层方法 如下图所示，具体细节在下一节中。 * 分层方法介绍 类似DNS 网络被划分为一组域 目录节点：记录域包含的实体 叶域的目录节点N记录实体E在域中的位置 更高一层域的目录节点N’记录实体E的位置，包含指向N的指针 这些节点构成一个目录节点树，顶级域的目录节点称为根（目录）节点，包含有全部的实体；根节点拥有每个实体的位置记录，其中每条位置记录都存储一个指向更底层子域目录节点的指针，该记录关联的实体当前就位于这里 实体可以拥有多个地址，比如它被复制了，就会出现这种情况，如果实体分别在叶域D1和D2中拥有地址，那么同时包含D1和D2的最小域的目录节点将有两个指针，每个指针都指向一个包含地址的子域，也就是下图中的效果（通用组织树） 描述分层方法中查找一实体的过程如下图所示，希望定位实体E的客户指向它所在的叶域D的目录节点发送一个查找请求。如果这个目录节点没有存储该实体的位置记录，那么就说明该实体不在D中。因此，这个节点会把请求转发给它的父节点。注意，这里父节点代表一个比它的子域更大的域，如果父节点也没有E的位置记录，那么就会把该查找亲求转发给更高一层的域，以此类推。 如果节点M存储了E的位置记录，那么一旦请求到达M后，就可以知道E位于节点M代表的域dom（M）中。如下图所示，M存储了一条位置记录，其中包含一个指向其子域的指针。然后，把请求转发给那个子域的目录节点，那个子域会依次进一步向树的下方转发请求，直到请求最终到达叶节点位置。存储在叶节点中的位置记录会包含E在哪一个叶域中的地址。这样就可以把这个地址返回给发起请求的客户。 一个与分层定位服务有关的重要因素是，查找操作是在局部进行的。原则上，对实体的搜索实在一个以发出查找请求的客户为中心，逐步增大的环中进行的。每当查找请求被转发到更高一层的目录节点是，都会扩大搜索区域。在最差情况下，搜索会连续进行。直至请求到达根节点为止。由于根节点拥有所有实体的位置记录，所以此时可以简单地沿着一条向下的指针路线把请求转发给一个叶节点。 描述分层方法中插入一实体的过程更新操作以与查找类似的方式在局部进行，如下图所示。假设实体E在叶域D中创建了一个副本，就需要插入这个副本的地址。插入操作从D的叶节点dir（D）开始，然后D会立即把插入请求转发给父节点。父节点同样会转发插入请求，直到插入请求到达已经为E存储了位置记录的目录节点M为止。 然后，节点M会在E的位置记录中存储一个指针，该指针指向转发插入请求的那个子节点。此时，该子节点会建立一条关于E的位置记录，该位置记录中包含一个指针，指向转发请求的下一层节点。这个过程会连续进行，直至到达发起请求的叶节点为止。最后那个叶节点会创建一条记录，这条记录包含实体在叶域中的位置。 也就是，插入请求转发到第一个知道实体E的节点；转发指向叶节点的指针所形成的链 刚才介绍的插入地址操作会导致一条从上到下建立的指针链，它从一个最底层的目录节点开始，该节点拥有实体E的位置记录。另一种是在向父节点发送插入请求之前创建一条位置记录。换句话说，就是从下往上建立指针链。后者的优点是地址会尽快变得可用。这样的话，即使父节点暂时无法到达，仍然可以在当前节点所在的域内查找实体的地址。 * 描述分层方法中删除一实体的过程删除操作与插入操作类似。如果需要删除叶域D中实体E的地址，那么需要请求目录节点dir（D）从它为E存储的位置记录中删除该地址。如果那条位置记录变成了空的，也就是说，它不在包含其他E在D中的地址，那么这条记录也可以删除。在这种情况下，dir（D）的父节点需要删除指向dir（D）的指针。如果父节点中有关E的位置记录也变空了，那么也应该删除这条位置记录，并通知更高一层的节点。以此类推，这个过程将连续进行，直到从一条位置记录中删除指针后该位置记录仍然非空或者是到达根节点为止。 C6 同步Lamport时间戳算法的思想基于Lamport算法，一种逻辑时钟同步化算法的被称为向量时间戳的Lamport扩展算法 时间戳（Time-Stamping）的算法： 网络上的每个系统（站点）维护一个计数器，起时钟的作用 每个站点有一个数字型标识，消息的格式为$(m,T_i,i)$，m为消息内容，$T_i$为时间戳，i为站点标识 当系统发送消息时，将时钟加一 当系统j接收消息时，将它的时钟设为当前值和到达时间戳这两者的最大值加一 在每个站点，时间的排序遵循以下规则：对来自站点i的消息x和站点j的消息y，如果 $T_i&lt;T_j$或$T_i=T_j$，且$i&lt;j$，则说消息x早于消息y 例如下图中，消息 a 最早，接下来是消息 x，接下来是消息 b，最后是消息 j；可以看到消息 b 和消息 j 的时间戳是相同的，但是消息 b 来自站点P1，消息 j 来自站点P3，1&lt;3，因此所有站点都认同消息 b 早于消息 j 的结论。 类似的，在下图的例子中，消息a早于消息q 哪个事件在实际上首先发生并不重要，重要的是所有进程对时间的发生顺序意见一致 * 选举算法选择一个进程作为协调者、发起者或其他特殊角色，一般选择进程号最大的进程（假设每个进程都知道其他进程的进程号，但不知道是否还在运行）；目的是：保证选举进行后，所有进程都认可被选举的进程。相关的算法包括：Bully算法、环算法、无线环境下的选举算法、大型系统中的选举算法。 选举算法中Bully算法的思想当进程P注意到需要选举一个进程作协调者时： 向所有进程号比它高的进程发ELECTION消息 如果得不到任何进程的响应，进程P获胜，成为协调者 如果有进程号比它高的进程响应，该进程接管选举过程，进程P任务完成 当其他进程都放弃时，只剩一个进程时，该进程成为协调者 一个以前被中止的进程恢复后也有选举权 下图例子中： 进程4启动选举 进程5和进程6响应，接管选举，成为协调者 进程6响应进程5的消息，接管选举，进程6成为协调者，通知所有进程 选举算法中环算法的思想 不使用令牌 按进程号排序，每个进程都知道自己的后继者 当进程P注意到需要选举一个进程作协调者时; 就创建一条包含该进程号的ELECTION消息，发给后继进程 后继进程再将自己的进程号加入ELECTION消息，依此类推 最后回到进程P，它再发送一条COORDINATOR消息到环上，包含新选出的协调者进程（进程号最大者）和所有在线进程 具体过程如下图所示： * 资源图下图是一种改进的资源图，图中只给出进程，每条弧穿过一个资源，为简单起见从图中删除了资源。 从图中可以看到：机器上的进程3正在等待两个资源，一个由进程4占有，一个由进程5占有；一些进程正在等待本地资源，例如进程1；一些进程，如进程2在等待其他机器上的资源。 分布式死锁检测Chandy-Misra-Haas算法的思想思想允许进程一次请求多个资源（加锁）而不是一次一个 通过允许多个请求同时进行使得事务的增长阶段加速 这使得一个进程可以同时等待两个或多个进程 例子当某个进程等待资源时，例如P0等待P1，将调用Chandy-Misra-Haas算法。生成一个探测消息发送给占用资源的进程。 消息由三个数组构成：阻塞的进程、发送消息的进程、接收消息的进程 例如，由P0到P1的初始消息包含三元组（0，0，1） 消息到达后，接受者检查以确认它自己是否也在等待其他进程。 若是，就更新消息，字段 1 保持不变，字段 2 改成当前进程号，字段 3 改为等待的进程号 然后消息接着被发送到等待的进程 若存在多个等待进程，就要发送多个不同的消息 不论资源在本地还是在远程，该算法一直继续下去。 下图中，（0，2，3），（0，4，6），（0，5，7）和（0，8，0）都是远程消息。 若消息转了一圈又回到了最初的发送者，即字段1所列的进程，就说明存在一个有死锁的环路系统。 * 打破死锁的方法可以有不同的方法打破死锁： 一种方法是使最初发送探测消息的进程自杀。如果有多个进程同时调用了此算法，那就会出现问题。例如在上节例中假设进程0-6同时阻塞，而且都初始化了探测消息。那么每个进程都会发现死锁，并且因此而自杀，然而这是不必要的。终止掉一个进程就足够了。 另一种算法是将每个进程的标识符添加到探测消息的末尾，这样当它返回到最初的发送者时，完整的环路就可以列出来了。于是发送者就能看出哪个进程编号最大，可以将它终止或者发送一个消息给它请求其自杀。 无论如何，如果多个进程同时发现了同一个环路，它们就一定会选择同一个牺牲者。 C7 一致性和复制复制的目的和代价 可靠性 性能 服务器数量扩展 地理区域扩展 代价：一致性 网络通信开销 强一致性要求的原子操作很难快速完成 解决办法：放宽一致性方面的限制，放款程度取决于复制数据的访问和更新模式以及数据的用途 * 以数据为中心的一致性模型 讨论共享数据读操作和写操作时的一致性问题 一致性模型实质上时进程和数据存储间的约定：如果进程同意遵守某些规则，数据存储将正常进行。正常情况下，进程的读操作应该返回最后一次写操作的结果 没有全局时钟，精确定义哪次操作是最后一次写操作是困难的 作为全局时钟的替代，产生了一系列一致性模型，每种模型都有效地限制了一个数据项上执行一次读操作所应返回的值 能区分是否符合严格一致性、顺序一致性、因果一致性和FIFO一致性 严格一致性（Strict Consistency）： 任何对数据项X的读操作将返回最近一次对X进行写操作的值 对所有进程来说，所有写操作都是瞬间可见的，系统维护着一个绝对的全局时间顺序 上图中：a) 严格的一致性存储；b)非严格的一致性存储 顺序和线性化一致性（Sequential and Linearizability Consistency） 2.1 顺序一致性 顺序一致性对存储器的限制比严格一致性要弱一些，要满足以下的条件： 每个进程的内部操作顺序是确定不变的 加入所有的进程都对某一个存储单元执行操作，那么，它们的操作顺序是确定的，即任一进程都可以感知到这些数据同样的操作顺序 上图中：a) 顺序一致的数据存储；b) 非顺序一致的数据存储 2.2 线性化 弱于严格一致性而强于顺序一致性 根据一系列时钟同步确定顺序（利用时间戳） 顺序一致性和线性化提供了程序开发人员在并发程序设计中期望的语义：所有写操作都已相同的顺序被每个进程看到 因果一致性（Casual Consistency） 所有进程必须以相同的顺序看到具有潜在因果关系的写操作 不同机器上的进程可以以不同的顺序看到并发的写操作 上图是，因果一致性存储允许的，但顺序和严格一致性存储不允许的顺序 上图中：a) 违背因果一致性的时间存储顺序；b) 符合因果一致性的时间存储顺序 FIFO一致性（FIFO Consistency） FIFO一致性模型是在因果一致性模型上的进一步弱化，它满足下面的条件： 由某一个进程完成的写操作可以被其他所有的进程按照顺序感知到，而从不同进程中来的写操作对不同的进程可以有不同的顺序。 下图是一个符合FIFO一致性的时间存储顺序 FIFO一致性与顺序一致性的区别： 顺序一致性：尽管语句的执行顺序是非确定的，但所有的进程对顺序达成一致。 FIFO一致性：各个进程不需要达成一致，不同进程可以以不同的顺序看到 一致性总结 | 一致性（Consistency） | 描述（Description） || ——————————- | —————————————————————————————— || 严格 | 所有共享访问按绝对时间排序 || 线性化 | 所有进程以相同顺序看到所有的共享访问。而且，访问时根据全局时间戳排序的 || 顺序 | 所有进程以相同顺序看到所有的共享访问。访问不是根据时间排序的 || 因果 | 所有进程以相同顺序看到因果相关的共享访问 || FIFO | 所有进程以不同进程提出写操作的顺序相互看到写操作。来自不同进程的写操作可以不必总是以相同的顺序出现 | * 以客户为中心的一致性模型 最终一致性（Eventual Consistency） 最终一致性：很多情况下系统能容忍相对较高程度的不一致性，共同之处在于：只有一个或少数几个进程执行更新操作，如果较长时间内没有更新操作，那么副本将逐渐成为一致的；例如：数据库系统，DNS，WWW 特点：只有少数几个进程执行更新操作，只需要处理读写冲突；能够容忍相对较高程度的不一致性；实现开销小。 如果客户总是访问同一副本，最终一致性能工作得很好 以客户为中心的一致性模型不考虑数据可能被多个用户共享的问题，而是集中考虑一个单独用户应被提供的一致性。 上图是用户访问分布式数据库不同副本的原理 能区分是否符合单调读、单调写、写后读和读后写 上图来自于题目，应该属于以数据为中心的一致性 单调读（Monotonic Reads） 定义：如果一个进程读取数据项x的值，那么该进程对x执行的任何后续读操作将总是得到第一次读取的那个值或更新的值 下图中描述了，进程P对同一数据存储的两个不同本地副本执行的读操作；L1，L2表示数据存储的两个不同的本地副本，水平轴表示时间。WS（x1；x2）表示WS（x1）的操作已在L2更新完毕。 图（a）表示保证单调读一致性的情况。图 (a) 中，进程P先在L1对x执行了一次读操作。该值是在L1执行的WS（x1）的结果。后来，P在L2对x执行了一次读操作，及图中的R（x2）。为了保证单调读一致性，WS（x1）中的所有操作都应该在执行第二个读操作前传播到L2。也就是说，我们需要确保WS（x1）是WS（x2）的一部分，记为WS（x1；x2）。 与之相对照，图（b）表示不保证单调读一致性的情况。进程P在L1读取x1后，由在L2执行R（x2）操作。然而，L2只执行了WS（x2）中的写操作。此时，不能保证集合WS（x2）同样包含WS（x1）中的所有操作。 单调写（Monotonic Writes） 定义：一个进程对数据项x执行的写操作必须在该进程对x执行的任何后续写操作之前完成 通过上述定义可看出，完成一个写操作意味着不管后续操作的启动位置，执行这个后续操作的副本都能反映出先前执行的写操作结果。也就是说，在数据项x的副本上执行的写操作只有在该副本已经通过任何先前的写操作进行更新之后才能被执行，而这些先前执行的写操作可能发生在x的其他副本上。 单调写一致性与以数据为中心的FIFO一致性类似。FIFO一致性的本质是，同一进程执行的写操作必须在任何地方以正确的顺序执行。这一顺序限制也适用于单调写一致性，只是我们这里考虑的是仅为单一进程维持的一致性，而不是为许多并发进程维持的一致性。 每个写操作完全覆盖x的当前值时，没有必要将x的副本更新为最新值，写操作通常指修改数据项的部分状态。 下图中描述了，进程P对同一数据存储的两个不同本地副本执行的写操作；图（a）为提供单调写一致性的数据存储；图（b）为不提供单调写一致性的顺序存储。 图（a）中，进程P在本地副本L1对x执行一次写操作，记为操作W（x1）。然后，进程P对x再执行一次写操作，但是这次是在L2出执行，如图中的W（x2）。为了保证单调写一致性，先前在L1执行的写操作必须已经传遍到L2。这就解释了图中L2处出现操作WS（x1），以及它出现在W（x2）之前的原因。 与之相对照，图（b）表示不保证单调写一致性的情况。与图（a）相比，图中没有向副本L2传播的W（x1）。也就是说，它不能保证x的副本上执行第二次写操作时，x的副本的值与执行完W（x1）时二点值相同或比之更新。 写后读（读写一致性，Read Your Writes） 定义：一个进程对数据项x执行的写操作总会被该进程对x执行的任何后续读操作看见 也就是说，一个写操作总是在同一进程执行的后续读操作之前完成，而不管这个后续读操作发生在什么位置。 下图（a）中描述了一个提供写后读一致性的数据存储；图（a）（b）非常相像，只是这里的一致性是通过进程P执行的最后一次写操作确定的，而不是通过进程P的最后一次读操作确定；图（a）为提供写后读一致性的数据存储；图（b）为不提供写后读一致性的顺序存储。 在图（a）中，进程P执行了一次写操作W（x1），然后在一个不同的本地副本处执行了一次读操作。写后读一致性保证，写操作的结果可以被所有后续的读操作看到。这一过程表示为WS（x1；x2），它表示W（x1）是WS（x2）的一部分。与之相对照，在图（b）中，W（x1）不在WS（x2）之中，这意味着进程P执行前一个写操作的结果还没有传播到。 读后写（写读一致性， Writes Follows Reads） 定义：同一个进程对数据项x执行的读操作之后的写操作，保证发生在与x读取之相同或更新的值上。 也就是说，进程对数据项x所执行的任何后续写操作都会在x的副本上执行，而该副本是用该进程最近读取的值更新的。 下图中描述了一个提供读后写一致性的数据存储；图（a）为提供读后写一致性的数据存储；图（b）为不提供读后写一致性的顺序存储。 在图（a）中，一个进程在本地副本L1处读取x。写入刚才所读取值的写操作也出现在L2处的写操作集合中。稍后，同一进程在L2处执行了一次写操作。注意，L2处的其他进程也看到了那些写操作。而图（b）中的数据存储无法保证L2处执行的操作是在与L1处所读的那个副本一致的副本上执行的。 基于主备份的协议：远程写协议、本地写协议 基于主备份的协议：每个数据x都有一个关联的主备份，负责协调x的写操作，根据主备份的位置分为：远程写协议，本地写协议 远程写协议 基于主备份的远程写协议，所有读操作和写操作都被转发到一个固定的服务器上 允许进程在本地可用的副本上执行读操作，但必须向一个固定的主拷贝上转发写操作 提供实现顺序一致性的直接方法 本地写协议 基于主备份的本地写协议，其中一个单一的拷贝在多个进程间移动 保证一致性 需要跟踪数据项的当前位置：广播、转发指针、基于原始位置的方法和层次定位服务。 多个连续的写操作可在本地进行，而读操作的进程还可以访问它们的本地拷贝 支持离线操作 主机备份协议，其中主备份移动到要执行更新的进程那里 复制的写协议：主动复制、基于法定数目的协议 复制的写协议：写操作可以在多个副本上执行 主动复制 写操作可以在多个副本上执行，每个副本对应一个进程，该进程执行更新操作 写操作导致更新传播 操作需要在各地按相同顺序进行： 时间戳(Lamport) 定序器 基于法定数目（多数表决）的协议 要更新一个文件，必须先联系至少半数加一个服务器，并得到它们同意后执行更新，修改文件后这些服务器上的文件将得到一个新的版本号；要读取一个文件，必须联系至少半数加一个服务器，请求它们返回该文件关联的版本号，若版本号一致则该版本为最新版本，因为剩余服务器的个数不够半数以上，试图只更新剩余服务器的请求将会失败。 Gifford方法：客户在读写一个复制的数据时，先向多个服务器提出请求，获得许可；读团体$N_R$，写团体$N_W$，$N$个副本；满足$N_R+N_W&gt;N,且 N_W&gt;N/2$ Gifford方法中，上述第一个条件用于防止读写操作冲突；而第二个限制条件用于防止读读操作冲突。只有在适当个数的服务器同意参与文件的读写后，客户才能读或写该文件。 下图中的三个实例：(a) 读集合和写集合的正确选择；(b)可能导致写写冲突的读集合和写集合，例如两个写集合{A, B, C, E, F, G}和{D, H, I, J, K, L}就会发生写写冲突；(c)读集合和写集合的正确选择，ROWA（read one, write all）。 C8 容错性什么是容错性 容错意味着系统即使发生故障也能提供服务 容错与可靠性相联系，包含以下需求： 可用性（Availability）：任何给定的时刻都能及时工作 可靠性（Reliability）：系统可以无故障地持续运行 安全性（Safety）系统偶然出现故障能正常操作而不会造成任何灾难 可维护性（Maintainability）发生故障的系统被恢复的难易程度 拜占庭将军问题这里被用于描述分布式系统中的进程故障，故障进程无法发送信息或发出干扰信息，影响其他进程的正常工作，导致系统一致性出现问题。 在拜占庭将军问题中，叛将代表故障进程，忠将代表正常进程。 Lamport的论文中提到的算法指出：如果存在k个叛将（故障进程），那么至少需要总共N=3k+1个将军（进程），才能最终达到一致的行动方案。 例如，下图中，有三个忠诚将军和一个叛将，叛将（故障进程）的代号是3，其余是忠诚将军（无故障进程），也就是k=1，N=4；简单来说，图（a）为将军宣布他们的兵力，图（b）为在（a）基础上每个将军收到的兵力组成的向量，图（c）为每个将军收到的向量；更具体地说，算法分为四步进行。 如图（a）；每个无故障进程 i 使用可靠单播给其他每个进程发送 vi ，这里假设 vi=i；故障进程则可能发送其他内容，且故障进程可能给不同进程发送不同的值，例如上图中故障进程3给其他进程1，2，4分别发送x，y，z。 如图（b）；每个进程把第一步收到的结果组织成向量形式。 如图（c）；把组织好的向量发送给其他进程，此时，每个进程将得到来自其他三个进程的三个向量；由于进程3是故障的，产生了$a-l$共12个值。 每个进程检查每个接收到向量中的第 i 个元素。如果存在占多数的值，那就将占多数的值放置到结果向量中；如果不存在占多数的值，那么结果向量的相应元素就标记为未知（UNKNOWN）。从（c）中可以看出，1、2、4都与v1、v2、v4的值一致，是正确的结果。从这些进程得出的结论无法确定v3，但也是不相关的。拜占庭协定的目标是一致性意见只与无故障进程的值有关。 下图中，有两个忠诚将军和一个叛将，叛将（故障进程）的代号是3，其余是忠诚将军（无故障进程），也就是k=1，N=3；在图（c）中，无故障进程的向量中无法看到元素1、2和3占大多数的情况，因此都标记为未知，该算法不能产生协定。 一些网络上的参考资料对拜占庭将军问题做了更加具体的说明。 拜占庭将军问题(The Byzantine Generals Problem)提供了对分布式共识问题的一种情景化描述, 由Leslie Lamport等人在1982年首次发表. 论文同时提供了两种解决拜占庭将军问题的算法： 口信消息型解决方案(A solution with oral message); 签名消息型解决方案(A solution with signed message). 本文之后将详细讲述这两种算法. 事实上, 拜占庭将军问题是分布式系统领域最复杂的容错模型, 它描述了如何在存在恶意行为(如消息篡改或伪造)的情况下使分布式系统达成一致. 是我们理解分布式一致性协议和算法的重要基础. 参考： 如何理解拜占庭将军问题？ 拜占庭将军问题 (The Byzantine Generals Problem) 拜占庭将军问题 (The Byzantine Generals Problem) 拜占庭将军问题 拜占庭问题与算法 什么叫原子多播 可实现存在进程失败情况下的可靠多播· 原子多播： 消息要么发送给所有进程，要么一个也不发送 通常需要所有的消息都按相同的顺序发送给所有的进程 分布式系统中的复制数据库 原子多播确保没有故障的进程对数据库保持一致；当一个副本从故障恢复并重新加入组时，原子多播强制它与其他组成员保持一致 原子多播=虚拟同步+消息排序 * 虚拟同步 虚拟同步： 保证多播到组试图的消息被传送给组中的每个正常进程 如果发送消息的进程在多播期间失败，则消息或者传递给剩余的所有进程，或者被每个进程忽略 所有多播都在视图改变之间进行 保证发送到组视图G的所有消息在组成员关系改变之前发送到G中的所有正常进程 进程4注意到进程7已经崩溃，发送一个视图改变 进程6发送所有的不稳定消息（所有进程都收到的消息称为稳定消息）然后发送一个flush消息 当进程6从其他每个进程收到flush消息后，建立一个新的视图 * 消息排序通常有以下四种排序方法 可靠不排序的多播：对接收不同进程发送的消息的次序不做任何保证 FIFO顺序的多播：按照消息发送的顺序传送同一进程的消息，对不同进程发送的消息的传送顺序没有约束 按因果关系排序的多播：按因果关系排序多播来保留消息间的因果关系 全序多播：无论消息传送是无序、FIFO顺序还是按因果关系排序，对所有的组成员按相同的次序传送 提供了全序的消息传送的虚拟同步可靠多播称为原子多播 分布式提交-两阶段提交的思想简单、使用、可靠，成为事实上的工业标准。 在两阶段提交（two-phase commit protocol, 2PC）协议中，将提交分为两个阶段 第一阶段（表决阶段）：事务的协调者询问各个参与者是否可以提交，此时，各个参与者将回答消息发送给协调者。协调者根据收到的消息，看是否可以真正提交。 第二阶段（完成阶段）：如果可以提交，则通知各参与者立即执行提交，否则，通知它们终止此事务。 下图中，图（a）为2PC中的协调者的有限状态机；图（b）为2PC中的参与者的有限状态机。 参与者一旦投票，则失去自主能力，必须等待协调者的最终决定，可能造成阻塞；可能的阻塞状态有： 参与者在INIT状态等待协调者的VOTE_REQUEST消息 协调者在WAIT状态等待来自每个参与者的表决 参与者在READY状态等待协调者发送的全局表决消息 下图中，列出了参与者P在READY状态下与另一个参与者Q联系时采取的行动。 当所有运行的参与者都处于READY状态时，尽管都已同意提交，但可能有崩溃的参与者（不一定同意提交），因而无法做出决定（即使选举出新的协调者），只能等待原协调者恢复。 下图为2PC中协调者采取的操作的伪码描述 下图为2PC中参与者采取的操作的伪码描述 下图中的伪码描述了处理（来自其他READY进程）决定请求的步骤 C9 分布式安全什么是机密性和完整性？ 机密性：系统将信息只向授权用户公开 完整性：对系统资源的更改只能以授权方式进行 对称加密系统和公钥系统的区别？ 对称加密系统：加密与解密密钥相同，即$P=D_K(E_K(P))$ 非对称加密系统：加密与解密密钥不同（一个公开、一个保密），但构成唯一的一对，即$P=D_{KD}(E_{KE}(P))$，也称为公钥系统 * 相关的资料 对称加密系统DES 公钥加密系统RSA MD5 什么是安全通道？安全通道：使客户与服务器之间的通信保持安全，免受对消息的窃听、修改和伪造的攻击。 * 身份验证身份验证：通信双方需要验证身份 * 消息的完整性和机密性消息的完整性和机密性：消息未受到窃听、修改和伪造的攻击 阐述基于共享密钥的身份验证的思想。质询-响应协议：一方向另一方质询一个响应，只有对方知道共享密钥时才能给予正确的响应。 下图的过程为： A希望联系B B发送质询RB A返回基于共享密钥加密RB后的信息$K_{A,B}(R_B)$ 接下来A发送质询RA B返回基于共享密钥加密RA后的信息$K_{A,B}(R_A)$ 若使用三个消息代替五个，则可能会出现错误，存在被反射攻击的风险 原因：协议的双方在两个不同方向都使用相同的质询 解决：协议的双方永远使用不同的质询 下图描述了反射攻击的过程，攻击者C通过建立两条信道，并将第二次质询的结果，作为第一次被质询的答案返回给B，假装C知道$K_{A,B}$以达到欺骗B冒充A的目的。 阐述使用密钥发布中心的身份验证的思想。基于共享密钥的身份验证可能存在扩展性问题：N台主机，需要$N*(N-1)/2$个密钥 使用密钥分发中心(Key Distribution Center, KDC)，系统中只需要管理N个密钥 KDC与每台主机共享一个密钥；下图展现了向通信的两台主机分发一个密钥的过程： 首先A告诉KDC期望与B通信; KDC返回分别使用A与KDC之间的密钥、B与KDC之间的密钥加密后的A与B之间的密钥，即$K_{A,KDC}(K_{A,B}), K_{B,KDC}(K_{A,B})$，将上述信息分别分发给A，B；这样就可以通信了 但上图中的方法存在缺点，A可能希望在B接收到来自KDC的共享密钥之前就开始与B建立安全通道，且需要KDC通知B进入通信中。为了解决这些问题，出现了下图中的协议； KDC返回分别使用A与KDC之间的密钥、B与KDC之间的密钥加密后的A与B之间的密钥，即$K_{A,KDC}(K_{A,B}), K_{B,KDC}(K_{A,B})$，将上述信息都分发给A，最后由A转发给B。$K_{B,KDC}(K_{A,B})$被称为票据，显然，只有B能够使用票据，因为加密票据的密钥只有KDC与B知道。 阐述使用公钥加密的身份验证的思想。使用公钥加密的审问认证的过程如下图所示，假定A、B都拥有彼此的公钥。 具体过程为： A向B发送一个是使用B的公钥$K_B^+$加密的质询RA，显然只有拥有B的私钥的人才能够解密该信息 B接收到信息后，会返回解密过后的质询RA、对A的质询RB、用于更进一步通信的会话密钥$K_{A,B}$；上述返回的信息均使用A的公钥$K_A^+$加密 最后，A返回一个使用会话密钥$K_{A,B}$对质询RB加密后的信息给B，证明确实是AB之间在交谈。这样连接就建立完毕，可以进行后续的对话 使用公钥加密对消息进行数字签名的思想。数字签名： 如果消息签名检验为真，发送者不能否认消息签名这一事实 消息与其签名的唯一关联防止了对消息进行修改而未发现的可能 使用公钥加密对消息进行数字签名 下图描述了使用公钥加密对消息进行数字签名的过程。 首先A，对原始消息m使用A的私钥$K_A^-$加密，作为签名，接下来为了使消息保密发出，使用B的公钥$K_B^+$进行第二轮加密，之后向B发出。 B收到消息后，首先使用B的私钥$K_B^-$解密，接下来使用A的公钥$K_A^+$解密，最后得到原始的信息；如果保证公钥确实属于A，那么解密m的签名版本以及成功地与m进行比较只能意味着该消息来自A。A受到防止B对m进行任何恶意修改的保护，因为B必须一直证明m的修改版本也是由A签名的。换句话说，经解密的消息本身在本质上从来不能作为证据。 但是上述方法还存在问题。比如： A可以声称其私钥在消息发送前被盗了 A可以改变其私钥 使用私钥加密整个消息的开销可能会过大；可使用消息摘要解决，消息摘要是固定长度的位串h=H(m), m是任意长度的消息，H是加密散列函数 下图描述了使用消息摘要对消息进行数字签名的过程 上图中，消息摘要使用A的私钥加密后发送，消息使用明文发送，若需要保密可使用B的公钥加密后发送；B得到消息与加密后的摘要后，单独计算消息得到所接收消息的摘要，并使用A的公钥解密收到的摘要，若计算出的摘要与解密后的摘要相匹配，则证明该消息是由A签名的。 Diffie-Hellman 建立共享密钥的原理。原理： 首先A和B双方约定两个大整数n和g，其中1&lt;g&lt;n;这两个整数无需保密，然后执行下面的过程： A随机选择一个大整数x（保密），并计算$X=g^x\\mod n$ B随机选择一个大整数y（保密），并计算$Y=g^y\\mod n$ A把X发送给B，B把Y发送给A A计算K=Y^x\\mod n = (g^y\\mod n)^x\\mod n=g^{xy}\\mod n B计算K=X^y\\mod n=(g^x \\mod n)^y \\mod n=g^{xy}\\mod n K即是共享的密钥 监听者在网络上只能监听到X和Y，但无法通过X、Y计算出x和y，因此无法计算出K 下图描述了上述原理中的过程： * 相关的资料 权能和委派。权能权能是对于指定资源的一种不可伪造的数据结构，它确切指定它的拥有者关于该资源的访问权限。 存在不同的权能实现方式，这里讨论的是Amoeba操作系统中所使用的实现方式。check字段用于是权能不可伪造；rights为权限位，rights在每种对象类型中的意义是不同的 为了调用一个对象的操作，客户必须将权能传递给服务器检查 服务器创建对象时，客户得到是所有者权能（全1），check字段是随机选择的，同时存储在权能和服务器的一个表中 客户可以从一个所有者权能生成一个受限权能，并发送给另一进程 委派委派：将某些访问权限从一个进程传递给另一个进程 例如： A可以构造证书，将权限R给证书的持有者，如B； A授权R给B，需要向B传递两部分内容，被称为代理，分别是证书，和证书中公钥$S^+_{proxy}$对应的私钥$S^-_{proxy}$。用于委派的一般代理结构如下所示： 证书由三部分构成，分别是权限R，公钥$S^+_{proxy}$和对证书的签名$sig(A,{R,S^+_{proxy}})$；证书可以使用明文传递。 公钥$S^+_{proxy}$对应的私钥$S^-_{proxy}$需要加密传递，用于检验B确实是被授权了。 使用代理来委派和证实访问的所有权的过程如下图所示： 具体过程为： 消息1传递委派代理给B，包括明文传递的由A签名的含有权限R和公钥$S^+_{proxy}$和密文传递的证书对应的私钥$S^-_{proxy}$ 消息2为B希望使用A赋予的权限R，在服务器执行操作 消息3为服务器向B确认B是否为权限的合法所有者，即使用证书中的公钥加密一个信息N对B质询 消息4为B返回使用私钥解密后的结果给服务器，证明B确实是该证书的合法持有者 显然，B还可以在A不知道的情况下，将权限赋予给其他人。 C10 分布式文件系统NFS的共享预约共享预约是一种锁定文件的隐含方法。共享预约完全独立于锁定，可用于在基于Windows的系统上实现NFS。客户打开文件时，需要指定所需的访问类型（即READ、WRITE或BOTH），以及服务器应该拒绝其他客户的访问类型。如果服务器不能满足客户的需求，那么该客户的open操作会失败。下图中确切地表示了一个新客户试图打开一个已被另一个客户成功打开的文件时的情况。对于一个已经打开的文件，使用两个不同的状态变量加以区分。访问状态表明当前客户目前如何访问该文件。拒绝状态表明新客户不要内需进行哪些访问。 上图中（a）表示给定一个文件的当前拒绝状态的情况下，客户试图请求以指定的访问类型打开此文件时所发生的事情；同样，（b）表示试图打开一个当前正被另一个客户访问的文件而所请求的访问类型不被该客户允许的情况。 NFS服务器的重复请求高速缓存 NFS的底层RPC不能保证可靠性，而且缺乏对重复请求的检测 NFS服务器提供重复请求高速缓存解决：XID事务处理标识符 具体描述为：每个来自客户的RPC请求都有一个唯一的XID。当RPC到来时，服务器缓存该XID。只要服务器还没有发出响应。就说明正在处理这个RPC请求。当服务器处理某个请求后，也缓存该请求的关联响应，与XID相联系，再将响应返回给客户。常见下图中三种情况： （a）客户端启动计时器，超时后客户仍未收到响应，因此使用原XID重发请求，若服务器收到了第一次请求但还没处理完成，则忽略第二次重发的请求 （b）服务器在返回响应后，收到了客户端的第二次请求，若返回响应的时间和收到第二次请求的时间接近，则忽略第二次请求 （c）服务器返回的响应丢失，且在相距应答发出后较远的时间收到了客户端发出的第二（或大于二）次请求，则重发该XID对应的响应结果 Coda的回叫（回调）承诺客户端缓存的重要性：可扩展性、容错性 Coda高速缓存了整个文件 回叫承诺：服务器记录哪些客户在本地缓存了文件的拷贝，如果文件被客户更改，会通知服务器，服务器会向其他客户发送无效化消息，（这种消息被称为回叫中断，也就是服务器废弃回叫承诺，这是因为服务器随后会将废弃它为刚刚向其发送了无效消息的客户保存的回叫承诺）如果客户在服务器上有未废弃的回叫承诺，它就可以安全地在本地访问文件。如下图中所示： 具体为当客户A开始会话$S_A$时，服务器会记录一个回叫承诺。同样，B开始会话$S_B$时也是如此。不过，当B关闭会话$S_B$时，服务器向客户A发送回叫终端，从而终端了它对回叫客户A的承诺。注意：由于Coda的事务处理语义，当客户A关闭会话$S_A$时，不会发生任何特殊的事情，整个关闭操作就像所预期的那样被简单地接收。 因此，当A随后要打开会话$S_A’$时，它会发现f本地的副本是无效的，所以它必须从服务器获取最新的版本。另一方面，当B开始会话$S_B’$是，它会注意到服务器仍有一个未被废弃的回叫承诺，该承诺意味着B可简单地重用从会话$S_B$获得的本地副本。 Coda的储藏技术 VSG（Volume Storage Group）是一个保存同一个复制卷的服务器集合。 可用的VSG成员叫做AVSG（Available VSG members）。 Coda使用ROWA（Read One, Write ALL）来维护复制卷的一致性 使用版本记录方案检测不一致性 下图描述了对于同一个复制文件，具有两个不同的AVSG的客户 Coda 允许客户在断开连接时（ASVG为空）的继续操作，基于本地备份，再次连接后回传服务器。基于事实：两个进程打开相同文件进行写操作很罕见。使用储藏技术（hoarding）。 也就是，为了成功地完成断开连接操作，需要解决的问题时确保客户缓存包含连接断开期间将访问的那些文件。如果采用简单的缓存方法，可以证明客户可能由于缺少必要的文件而不能继续执行。预先使用适当的文件填充高速缓存称为储藏。 下图描述了对于一个卷，Coda客户的状态转换图： END2023.2.8","categories":[{"name":"课程","slug":"课程","permalink":"/categories/课程/"}],"tags":[{"name":"课程","slug":"课程","permalink":"/tags/课程/"},{"name":"高级操作系统","slug":"高级操作系统","permalink":"/tags/高级操作系统/"},{"name":"分布式","slug":"分布式","permalink":"/tags/分布式/"}],"keywords":[{"name":"课程","slug":"课程","permalink":"/categories/课程/"}]},{"title":"2022秋学期 高级操作系统课件后习题","slug":"2022秋学期-高级操作系统课件后习题","date":"2023-02-12T09:34:47.000Z","updated":"2023-02-26T02:49:23.466Z","comments":true,"path":"2023/02/12/2022秋学期-高级操作系统课件后习题/","link":"","permalink":"/2023/02/12/2022秋学期-高级操作系统课件后习题/","excerpt":"","text":"2022秋学期 高级操作系统课件后习题C0 引言本文内容来自于对高级操作系统课程PPT后习题的整理与解答，部分章节课件后没有习题，且答案不一定完全准确，敬请批评指正； 本文所涉及的课程指东北某沿海高校，计算机学院硕士生必修课“高级操作系统”，课程资料包括课程PPT、教材《分布式系统原理与范型 第二版》1、《Distributed Systems Principles and Paradigms 2nd edition》2，以及网络资料。 1. 《分布式系统原理与范型 第二版》 作者: （美）特尼博姆 出版社: 清华大学出版社 原作名: Distributed Systems: Principles and Paradigms 译者: 辛春生 :出版年: 2008-6-1 页数: 490 ISBN: 978730217279 &#8617; 2. 《Distributed Systems Principles and Paradigms 2nd edition》:作者: Tanenbaum, Andrew S. / Steen, Maarten van 出版社: Pearson 出版年: 2001-9-1 页数: 803 ISBN: 9780131217867 &#8617; C2 体系结构 (C2Q4)考虑一个进程链，该进程（链）由进程$P_1,P_2,\\dots P_n$构成，实现了一个多层客户-服务器体系结构。进程$P_i$是$P_{i+1}$的客户，只有$P_i$得到$P_{i+1}$的应答之后，才能向$P_{i-1}$发出应答。如果考虑到进程$P_{1}$的请求-应答性能，这种组织结构主要存在什么问题？ 答：当n很大时性能可能会很差。两个连续层的通信可能会在不同的机器上，这样P1和P2的交互性能就取决于其他 n-2 层之间的交互性能。且，若进程链中的某台机器性能较差或者暂时无法联系，进程链的性能将显著下降。 C3 分布式进程管理 （C3Q1）比较在单处理器系统中，使用单线程文件服务器和使用多线程文件服务器读取文件有什么区别。假定需要的数据存放在内存的缓存中（概率为2/3），将花费30ms来接收请求、调度该请求并且完成其他必须的处理工作。否则需要磁盘操作，就需要额外多花90ms，在磁盘操作的过程中线程处于等待状态。 如果服务器采用单线程，每秒能处理多少个请求？ 如果服务器采用多线程呢？ 答： 对于单线程： t=30*2/3+(30+90)*1/3=60msn=1s/t=50/3个也就是每秒50/3个 对于多线程：磁盘操作涉及的等待状态可以交给其他线程，因此每个请求所需的时间就是接收请求与调度的30ms t=30msn=1s/t=100/3个也就是每秒100/3个 （C3Q2）对服务器进程中的线程数目进行限制是否有意义？ 答：显然有，主要有两个原因： 线程需要内存空间来设置私有堆栈，过多的线程可能会占据过多的内存使服务器无法正常工作 对于操作系统来说，独立的线程往往以混乱的方式运行。在虚拟内存系统中构造一个相对稳定的工作集时很困难的，导致了许多页错误以及相应的I/O操作。过多的线程可能因为页错误而使得性能下降。甚至在那些内存正常的情况下，我们可能很容易看到内存的访问是按照混乱的模式进行的，从而导致缓存毫无用处。这可能会导致性能甚至不如单线程。 （C3Q10）列举通过生成进程来构建并发服务器与使用多线程服务器的优点和缺点。 答：一个重要的有点是独立的进程时相互保护的，这是很有必要的，例如在超级服务器上处理独立的服务。另一方面，进程的产生是的代价是相对较高的，这些代价在多线程服务器中可以被节省。此外，如果进程间需要通信，使用线程的代价相对低得多，因为在许多情况下我们可以避免使用内核通信。 C5 命名系统 （C5Q12）假设某个移动实体几乎不会离开域D，即使离开也很快返回。如何利用该信息在分层定位服务中加快查询操作的速度？ 答：只需要在实体的标识符中对域D进行编码，该标识符被用于查询查询实体的操作。这样查询操作就可以立即被转发到目录节点dir（D）中，并从这里开始继续搜索。 （C5Q14）假设一个实体从位置A转移到位置B，期间经过了几个中间位置（停留时间都很短），最终到达B。在分层定位服务中更改地址可能花费较长时间，因此在经过中间位置时，应避免更改地址没那么经过中间位置时应该如何查找该实体？ 答：将分层定位于与转发指针相结合。当实体开始移动时，在A出留下一个转发指针指向其下一个（中转）位置。每次移动时，都在移动开始处留下一个转发指针。直到到达B，将实体的新位置插入到分层定位服务中。转发指针链随后被清理，而A的原位置被删除。 （C5Q13）在深度为k的分层定位服务中，当移动实体改变它的位置时，最少需要更新多少条位置记录？最多需要多少条位置记录？ 答：改变位置可以被描述为一次插入与一次删除操作的结合。一次插入操作最多要求改变k+1条记录。同样的，一次删除操作最多要求修改k+1条记录。而根节点的记录修改可以被两个操作所共享，也就是仅需要修改一次根节点的记录。因此最多需要修改2k+1条记录。 显然，修改记录最少时，要求k=1，此时，最少需要修改3条记录。 C6 同步 （C6Q11）分布式互斥算法中，建议所有的请求都被应答（同意或否定），这样可以检测出崩溃的进程，但是否还有其它问题？ 答：假定某进程P拒绝了请求随后崩溃了。这样请求进程认为P仍然运行，但授权永远不会到来。一个解决办法是让请求进程不阻塞，而是在休眠一个固定时间后，轮询所有之前拒绝过的进程，看它们是否仍在运行。 （C6Q8）许多分布式算法需要协调者，与集中式协调者相比，分布性体现在哪里？ 答：在集中式算法中，通常由一个固定的进程作为协调者。分布式的情况下，不同的进程在不同的机器上运行。在分布式算法中，有不固定的协调者。协调者是由构成算法的一部分进程举（分布式的方式）产生的。这样的协调者并没有让算法的分布程度降低。 C7 一致性和复制 （C7Q20）一个文件被复制在10个服务器上，列出基于法定数目的协议允许的所有读团体和写团体。 答：允许的读团体和写团体有（读团体，写团体）：（1，10），（2，9），（3，8），（4，7），（5，6），（6，5），（7，4），（8，3），（9，2），（10，1）。 C8 容错性 （C8Q7）下面情况下，最少一次语义合适还是最多一次语义合适？ 从文件服务器读写文件 编译一个程序 远程银行 答：对于从文件读写文件、编译一个程序来说，可以使用最少一次语义，因为多次并没有问题。对于远程银行来说，使用最多一次语义，因为如果失败，用户必须干预并清理上一次的残留。 （C8Q14）下图中，FIFO和全序结合情况下。可能的消息发送顺序？ 答：可能的发送顺序有： m1, m2, m3, m4 m1, m3, m2, m4 m1, m3, m4, m2 m3, m1, m4, m2 m3, m4, m1, m2 m3, m1, m2, m4 C9 分布式安全 (C9Q10) Assume Alice wants to send a message m to Bob. Instead of encrypting m with Bob’s public key $K_B^+$, she generates a session key $K_{a,b}$ and then sends $[K_{A,B}(m),K^+_B(K_{A,B})]$.Why is this scheme generally better? (Hint: consider performance issues.) 答：因为会话密钥（session key），具有短且固定的长度，而消息m的长度是任意的。这样的特性导致组合使用会话密钥与公钥加密短消息能够得到更好的性能，而只使用公钥对长信息加密的性能相对较差。 (C9Q19) The Diffie-Hellman key-exchange protocol can also be used to establish a shared secret key between three parties. Explain how. 答：假定Alice、Bob、Chunk想要基于两个公开的大素数$n$和$g$建立共享密钥。Alice拥有一个不公开的大数$x$，Bob拥有不公开的大数$y$，Chunk拥有不公开的大数$z$。Alice将$g^x \\mod n$发送给Bob；Bob将$g^y\\mod n$发送给Chunk；Chunk将$g^z\\mod n$发送给Alice。接下来，Alice计算$g^{xz}\\mod n$，并将计算的结果发送给Bob；这样，Bob可以计算$g^{xyz}\\mod n$；同时，在Bob接收到Alice发送的$g^x \\mod n$后，可以计算$g^{xy}\\mod n$，并将计算的结果发送给Chunk；这样，Chunk可以计算$g^{xyz}\\mod n$；同时，在Chunk接收到Bob发送的$g^y \\mod n$后，可以计算$g^{yz}\\mod n$，并将计算的结果发送给Alice；这样，Alice也可以计算$g^{xyz} \\mod n$。通过上述操作就建立了一个三方之间的共享密钥。 (C9Q20) There is no authentication in the Diffie-Hellman key-exchange protocol. By exploiting this property, a malicious third party, Chunk, can easily break into the key exchange taking place between Alice and Bob, and subsequently ruin the security. Explain how this would work. 答：假定Alice和Bob使用公开的n和g，当Alice发送$g^x\\mod n$给Bob时，Chunk只需拦截该信息，返回其自己的信息$g^z\\mod n$给Alice，这样可以让Alice相信她正在与Bob交谈。类似的，在Chunk拦截Alice的信息后，他可以发送$g^z\\mod n$给Bob，并等待Bob返回$g^y\\mod n$作为应答。Chunk现在作为中间人了","categories":[{"name":"课程","slug":"课程","permalink":"/categories/课程/"}],"tags":[{"name":"课程","slug":"课程","permalink":"/tags/课程/"},{"name":"高级操作系统","slug":"高级操作系统","permalink":"/tags/高级操作系统/"},{"name":"分布式","slug":"分布式","permalink":"/tags/分布式/"}],"keywords":[{"name":"课程","slug":"课程","permalink":"/categories/课程/"}]},{"title":"基于hexo的github博客搭建","slug":"基于hexo的github博客搭建","date":"2023-02-09T07:06:00.000Z","updated":"2023-02-09T08:19:51.000Z","comments":true,"path":"2023/02/09/基于hexo的github博客搭建/","link":"","permalink":"/2023/02/09/基于hexo的github博客搭建/","excerpt":"","text":"前言本文写作时间跨度较大，可能出现部分内容不准确以及部分章节风格不一致的情况。 博客的前期搭建主要参考： 2021年最全搭建+美化+使用博客教程 | Recluse (reclusew.github.io) 博客的美化修改主要参考： Uncle_drew (cndrew.cn) 本博客使用的主题是 sakura 还推荐使用主题 GitHub - blinkfox/hexo-theme-matery: A beautiful hexo blog theme with material design and responsive design.一个基于材料设计和响应式设计而成的全面、美观的Hexo主题。国内访问：http://blinkfox.com 前期准备首先，需要有GitHub账号，可使用邮箱注册；满足条件提交材料还可以领取学生礼包。 还需要安装一些环境，可参考网上其他教程安装，例如参考中给出的链接 安装 node.js、安装 git、安装 hexo参考2021年最全搭建+美化+使用博客教程 | Recluse (reclusew.github.io) 1.1 注意事项 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行 hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导 hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的 1.2 下载并安装node.js 官网下载：https://nodejs.org/en/ 安装与使用：见node笔记 安装后验证：node -v 1.3 下载并安装git 官网下载: https://git-scm.com/download/win 安装与使用：见git笔记 安装后验证：git -v 1.4 命令行安装cnpm 命令：npm install -g cnpm –registry==https://registry.npm.taobao.org 安装后验证：cnpm -v 1.5 命令行安装hexo 命令：cnpm install -g hexo-cli 安装后验证：hexo -v 配置github的博客仓库参考2021年最全搭建+美化+使用博客教程 | Recluse (reclusew.github.io) 2.配置github2.1 在github上创建仓库创建： 新建一个名为你的用户名.github.io的仓库 比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 注意： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久； 创建页面如下： 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 2.2 绑定域名（这步可省略）当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。 首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！ 绑定域名分2种情况：带www和不带www的。 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me 另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 SSH连接参考2021年最全搭建+美化+使用博客教程 | Recluse (reclusew.github.io) 3. 配置SSH免密登录为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 操作步骤： 第一步：首先打开电脑文件夹，找到C:\\Users\\你的用户名.ssh文件夹并删除 第二步：在C:\\Users\\你的用户名 文件夹下右键打开Git Bash Here输入命令：ssh-keygen -t rsa -C github邮件地址 生成.ssh秘钥，输入后连敲三次回车，出现下图情况代表成功 第三步：最终生成了一个新的 C:\\Users\\你的用户名.ssh文件夹，打开这个文件夹，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容 第四步：打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title随便填，保存即可，我们的公钥就添加成功了，设置好如下图。 第五步：检测是否设置成功： 输入命令： $ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 第六步：此时你还需要配置： $ git config –global user.name “liuxianan”// 你的github用户名，非昵称 $ git config –global user.email “xxx@qq.com“// 填写你的github注册邮箱 具体这个配置是干嘛的我没仔细深究。 本地hexo初始化与部署参考2021年最全搭建+美化+使用博客教程 | Recluse (reclusew.github.io) 4.使用 hexo 搭建博客4.1 初始化第一步：在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\\xpzsData\\hexocode，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放 第二步：在E:\\xpzsData\\hexocode文件夹下右键打开 Git Bash Here，输入hexo init 初始化 hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 第三步：执行以下命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： 第四步：hexo s 是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章https://www.runoob.com/w3cnote/windows-finds-port-usage.html 到这里初始化就完成了 4.2 将博客部署到 github 个人主页上第一步：在E:\\xpzsData\\hexocode目录下安装 hexo-deployer-git 插件 安装命令： npm install hexo-deployer-git –save 必须安装，否则执行hexo d 的话会报如下错误： 第二步：编辑E:\\xpzsData\\hexocode目录下的 _config.yml 文件, 在文件末尾添加如下内容： 注意：其中 repo 中的内容即为 github 个人主页链接地址，具体看下图： 第三步：在E:\\xpzsData\\hexocode目录下, 输入命令：hexo d 将本地 blog 推送到 github仓库, 也可能需要输入 username &amp; pwd。 推送成功后, 在浏览器中输入对应域名, 即可访问 https://reclusew.github.io/ 更换博客主题由于自带的主题确实是一言难尽，因此更换主题是很有必要的。 hexo提供的主题站为： https://hexo.io/themes/ 可以在主题站上下载主题，把选定主题git clone至hexo文件夹下的themes中再修改相关配置文件；或是直接参考选定主题的文档配置； 每次修改需要重新生成，部署 这里选择的主题是：sakura 该主题的文档为 (首页 - Hexo-Sakura (hojun.cn)) 首先，如下图所示，下载该主题压缩包，将压缩包的子目录下的内容提取至hexo根目录，替代冲突项，安装依赖包 需要解压替换的内容 替换后参考主题的文档，修改配置文件即可 写博客与发布# 在博客的根目录 hexo new &quot;newbolg&quot; # 新的博客 hexo new page &quot;newpage&quot; # 新的网站页面 # hexo 生成 hexo g # hexo 本地预览 hexo s # hexo 部署 hexo d 可能涉及的命令# npm 安装 npm i [可填包名] # npm 安装 换源 npm i [可填包名] --registry https://registry.npm.taobao.org # hexo 生成 hexo g # hexo 本地预览 hexo s # hexo 部署 hexo d # 清理本地public等目录的文件 hexo clean 其他的问题hexo及其相关组件版本问题在需要更新的时候一定要慎重，一定记录更新了那些内容！有时候使用旧版本hexo可以避免很多问题！特别是这里使用的Sakura主题，已经有一定的历史了，更新后可能会出现莫名其妙的bug # 安装 npm install 包 # 卸载 npm uninstall 包 hexo init、获取主题时 网络卡住这个问题比较玄学，笔者在这里卡了很久。可能的原因是连接github网络不稳定 可以换一个连接性好一点的网，或者多试几次，总会成功的… 或者参考以下解决方案思路，由于没有试过不知道效果如何 彻底解决 hexo init 卡顿问题 - 简书 (jianshu.com) 图片相关问题如果使用markdown写博客，且把图片保存在本地，上传时可能会出现问题，因为markdown文件的图片是依据路径寻找的而不是再文件中的，因此可以使用图床，这样在上传后路径就不会被影响了 免费的图床还是有一些的，但空间不会特别大，一般也够用了， 例如 Image Upload - SM.MS - Simple Free Image Hosting 或者参考使用github搭建的jsdilvr，也是免费好用的，具体过程可参考： 使用jsDelivr+github搭建免费的cdn | 流年，谁给过的倾城 | Yremp 免费 CDN：jsDelivr + Github - BOB’S BLOG (itbob.cn) Github + jsDelivr + PicGo 打造稳定快速、高效免费图床 - BOB’S BLOG (itbob.cn) Sakura主题notice改成随机格言可参考「Sakura主题美化与修改#01」Hexo-Sakura主题首页的美化和修改 的第四点 进入从博客更目录出发的themes/Sakura/layout/index.ejs，查找&lt;%= theme.notice%&gt;，将其替换为以下内容： 若觉得格言内容单一，可参照语句接口 | 一言开发者中心的内容修改下述代码第六行的链接，例如全都要的话，可以写成这样https://v1.hitokoto.cn/?c=a&amp;c=b&amp;c=c&amp;c=d&amp;c=e&amp;c=f&amp;c=g&amp;c=h&amp;c=i&amp;c=j&amp;c=k&amp;c=l &lt;span id=&quot;hitokoto&quot; style=&quot;margin-left:5px;&quot;&gt; :D 获取中...&lt;/span&gt; &lt;p align=&quot;right&quot; id=&quot;afrom&quot;&gt;&lt;/p&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; fetch(&#39;https://v1.hitokoto.cn/?c=h&#39;) .then(function (res){ return res.json(); }) .then(function (data) { var hitokoto = document.getElementById(&#39;hitokoto&#39;); var afrom = document.getElementById(&#39;afrom&#39;); hitokoto.innerText = data.hitokoto; afrom.innerText = &#39;——【&#39; + data.from + &#39; &#39; + data.from_who + &#39;】&#39;; }) .catch(function (err) { console.error(err); }) &lt;/script&gt; 附上接口的参数含义 请求地址 # 地址 协议 方法 QPS 限制 线路 v1.hitokoto.cn HTTPS Any 3.5 全球 international.v1.hitokoto.cn HTTPS Any 10 国外 请注意：一言域名已加入 HSTS 预加载计划，所有请求一律以 HTTPS 方法进行。 请求参数 # 参数 值 可选 说明 c 见后表 是 句子类型 encode 见后表 是 返回编码 charset 见后表 是 字符集 callback 如：moe 是 调用的异步函数 select 默认：.hitokoto 是 选择器。配合 encode=js 使用 min_length 默认：0 是 返回句子的最小长度（包含） max_length 默认：30 是 返回句子的最大长度（包含） 句子类型（参数） # 参数 说明 a 动画 b 漫画 c 游戏 d 文学 e 原创 f 来自网络 g 其他 h 影视 i 诗词 j 网易云 k 哲学 l 抖机灵 其他 作为 动画 类型处理 可选择多个分类，例如： ?c=a&amp;c=c 返回编码（参数） # 参数 说明 text 返回纯洁文本 json 返回格式化后的 JSON 文本 js 返回指定选择器的同步调用函数。默认选择器为：.hitokoto 其他 返回格式化后的 JSON 文本 字符集（参数） # 参数 说明 utf-8 返回 utf-8 编码的内容 gbk 返回 gbk 编码的内容。不支持与异步函数同用 其他 返回 utf-8 编码的内容 返回格式 # 返回参数名称 描述 id 一言标识 hitokoto 一言正文。编码方式 unicode。使用 utf-8。 type 类型。请参考第三节参数的表格 from 一言的出处 from_who 一言的作者 creator 添加者 creator_uid 添加者用户标识 reviewer 审核员标识 uuid 一言唯一标识；可以链接到 https://hitokoto.cn?uuid=[uuid] 查看这个一言的完整信息 commit_from 提交方式 created_at 添加时间 length 句子长度 Sakura主题恢复原有的主题切换按键可参考「Sakura主题美化与修改#01」Hexo-Sakura主题首页的美化和修改的最后一点， 该部分的前端展示在Hexo版本的Sakura主题被作者中删除了，但其js和css代码并未删除。若要恢复切换主题背景的功能，需在从博客根目录出发的themes/Sakura/layout/layout.ejs中的标签前添加以下内容： &lt;!-- 实现换肤功能 --&gt; &lt;%- partial(&#39;_partial/skin-list&#39;) %&gt; &lt;%- partial(&#39;_partial/skin-btn&#39;, null, {cache: !config.relative_link}) %&gt; &lt;%- partial(&#39;_partial/mheader&#39;, null, {cache: !config.relative_link}) %&gt; &lt;%- partial(&#39;_partial/aplayer&#39;, null, {cache: !config.relative_link}) %&gt; &lt;/body&gt; &lt;/html&gt; 随后在themes/Sakura/layout/_partial文件夹下依次新建skin-btn.ejs和skin-list.ejs， skin-btn.ejs的内容为： &lt;div class=&quot;changeSkin-gear no-select&quot;&gt; &lt;div class=&quot;keys&quot; id=&quot;setbtn&quot;&gt; &lt;span id=&quot;open-skinMenu&quot;&gt; 切换主题 | SCHEME TOOL &lt;i class=&quot;iconfont icon-gear inline-block rotating&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; skin-list.ejs的内容为： &lt;div class=&quot;skin-menu no-select&quot; id=&quot;mainskin&quot; style=&quot;position: fixed&quot;&gt; &lt;div class=&quot;theme-controls row-container&quot;&gt; &lt;ul class=&quot;menu-list&quot;&gt; &lt;li id=&quot;white-bg&quot;&gt; &lt;i class=&quot;fa fa-television&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;sakura-bg&quot;&gt; &lt;i class=&quot;iconfont icon-sakura&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;gribs-bg&quot;&gt; &lt;i class=&quot;fa fa-slack&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;KAdots-bg&quot;&gt; &lt;i class=&quot;iconfont icon-dots&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;totem-bg&quot;&gt; &lt;i class=&quot;fa fa-optin-monster&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;pixiv-bg&quot;&gt; &lt;i class=&quot;iconfont icon-pixiv&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;bing-bg&quot;&gt; &lt;i class=&quot;iconfont icon-bing&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;dark-bg&quot;&gt; &lt;i class=&quot;fa fa-moon-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;canvas id=&quot;night-mode-cover&quot;&gt;&lt;/canvas&gt; 随后你就可以在右下角得到前端切换背景的控制面板： 背景图片可以在themes/Sakura/source/js/sakura-app.js中更换，其位置为 changeBG(&#39;#sakura-bg&#39;, &#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/themebg/sakura.png&#39;) changeBG(&#39;#gribs-bg&#39;, &#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/themebg/plaid.jpg&#39;) changeBG(&#39;#pixiv-bg&#39;, &#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/themebg/star.png&#39;) changeBG(&#39;#KAdots-bg&#39;, &#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/themebg/point.png&#39;) changeBG(&#39;#totem-bg&#39;, &#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/themebg/little-monster.png&#39;) changeBGnoTrans(&#39;#bing-bg&#39;, &#39;https://api.shino.cc/bing/&#39;) $(&#39;.skin-menu #white-bg&#39;).click(function () { mashiro_global.variables.skinSecter = false mashiro_global.variables.isNight = false $(&#39;#night-mode-cover&#39;).css(&#39;visibility&#39;, &#39;hidden&#39;) $(&#39;body&#39;).css(&#39;background-image&#39;, &#39;none&#39;) $(&#39;.blank&#39;).css(&#39;background-color&#39;, &#39;rgba(255,255,255,.0)&#39;) $(&#39;.pattern-center-sakura&#39;).removeClass(&#39;pattern-center-sakura&#39;).addClass(&#39;pattern-center&#39;) $(&#39;.headertop-bar-sakura&#39;).removeClass(&#39;headertop-bar-sakura&#39;).addClass(&#39;headertop-bar&#39;) $(&#39;#banner_wave_1&#39;).removeClass(&#39;banner_wave_hide_fit_skin&#39;) $(&#39;#banner_wave_2&#39;).removeClass(&#39;banner_wave_hide_fit_skin&#39;) closeSkinMenu() setCookie(&#39;bgImgSetting&#39;, &#39;&#39;, 30) }) $(&#39;.skin-menu #dark-bg&#39;).click(function () { mashiro_global.variables.skinSecter = true mashiro_global.variables.isNight = true $(&#39;body&#39;).css(&#39;background-image&#39;, &#39;url(https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/starry_sky.png)&#39;) $(&#39;.blank&#39;).css(&#39;background-color&#39;, &#39;rgba(255,255,255,.8)&#39;) $(&#39;#night-mode-cover&#39;).css(&#39;visibility&#39;, &#39;visible&#39;) $(&#39;.pattern-center&#39;).removeClass(&#39;pattern-center&#39;).addClass(&#39;pattern-center-sakura&#39;) $(&#39;.headertop-bar&#39;).removeClass(&#39;headertop-bar&#39;).addClass(&#39;headertop-bar-sakura&#39;) $(&#39;#banner_wave_1&#39;).addClass(&#39;banner_wave_hide_fit_skin&#39;) 替换其中所有图片的url即可完成更换。 如果还是没有的话，可在sakura-app.js里的scrollBar函数中，依据滚动的距离，添加 // 使该按键出现， $(&#39;.changeSkin-gear&#39;).css(&#39;visibility&#39;, &#39;visible&#39;).css( &#39;bottom&#39;, &#39;0px&#39;) // 使该按键隐藏 $(&#39;.changeSkin-gear&#39;).css({&#39;visibility&#39;:&#39;hidden&#39;}) Sakura主题配置latex公式需要首先参考文档关掉设置中的pjax，在主题/_congfig.yaml下，接着参考如下配置 如何在 hexo 中支持 Mathjax？ 具体过程为 在 hexo 中，你会发现我们不能用 Latex 语法来书写数学公式，这对于书写学术博客来说是很大的不便，因为我们会经常碰到很多的数学公式推导，但是我们可以通过安装第三方库来解决这一问题。 第一步： 使用Kramed代替 Markedhexo 默认的渲染引擎是 marked，但是 marked 不支持 mathjax。 kramed 是在 marked 的基础上进行修改。我们在工程目录下执行以下命令来安装 kramed. npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save 然后，更改/node_modules/hexo-renderer-kramed/lib/renderer.js，更改： // Change inline math rule function formatText(text) { // Fit kramed&#39;s rule: $$ + \\1 + $$ return text.replace(/`\\$(.*?)\\$`/g, &#39;$$$$$1$$$$&#39;); } 为： // Change inline math rule function formatText(text) { return text; } 第二步: 停止使用 hexo-math首先，如果你已经安装 hexo-math, 请卸载它： npm uninstall hexo-math --save 然后安装 hexo-renderer-mathjax 包： npm install hexo-renderer-mathjax --save 第三步: 更新 Mathjax 的 CDN 链接首先，打开/node_modules/hexo-renderer-mathjax/mathjax.html 然后，把&lt;script&gt;更改为： &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 第四步: 更改默认转义规则因为 hexo 默认的转义规则会将一些字符进行转义，比如 _ 转为 &lt;em&gt;, 所以我们需要对默认的规则进行修改.首先， 打开&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js, 注：也就是博客根目录/node_modules/kramed/lib/rules/inline.js, 然后，把: 注：在11行左右 escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, 更改为: escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/, 把 注：在20行左右 em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 更改为: em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 第五步: 开启mathjax在主题 _config.yml 中开启 Mathjax， 找到 mathjax 字段添加如下代码： 注：在根目录/themes/Sakura/_config.yml 中开启 Mathjax， 找到 mathjax 字段添加或修改如下代码，笔者这里是修改，是好用的： mathjax: enable: true 这一步可选，在博客中开启 Mathjax，， 添加以下内容： 注：这一步没找到在哪，不做也可以 --- title: Testing Mathjax with Hexo category: Uncategorized date: 2017/05/03 mathjax: true --- 通过以上步骤，我们就可以在 hexo 中使用 Mathjax 来书写数学公式。 添加分类雷达、分类云、标签词云、标签云、仿Github日历、文章分类统计等组件在看到了Uncle_drew (cndrew.cn)的博客之后，觉得里面的分类雷达、分类云，标签词云，标签云的样式非常棒，就添加在了自己的博客中。这些其实是来自于hexo-theme-matery的组件，分别是目录 hexo-theme-matery/layout/_widget/下的: （分类雷达）category-radar.ejs （分类云）category-cloud.ejs （标签词云）tag-wordcloud.ejs （标签云）tag-cloud.ejs （文章分类统计） post-charts.ejs 此外，Uncle_drew (cndrew.cn)的文章中还提到了仿Github的文章发布日历图，但在Uncle_drew (cndrew.cn)的网站中好像已经弃用了，在本站中该组件放到了归档页上。该组件也来自于hexo-theme-matery （仿github发布日历）post-calendar.ejs 添加方法可以参考下述的链接。简单说就是将组件下载下来后，在指定页面插入该组件即可，需要注意的是仅仅下载ejs组件往往是不够的，需要补充基础的js、css文件，并且在各个组件中修改原有导入的js、css路径。最后依据不同博客的情况调整，美化页面，避免与博客原有内容冲突。 例如： &lt;%- partial(&#39;_widget/post-charts&#39;) %&gt; 可能的js文件有： jquery-3.3.1.min.js jqcloud-1.0.4.min.js echarts.min.js 可能的css文件有： jqcloud.css matery.css 本部分的ejs文件可以在matery中下载。 参考的链接：需要注意的是，笔者写文时Uncle_derw有关页面中提到的文件有许多是无法下载的，因此需要到matery或其他位置下载 花里胡哨的Hexo | 给你的hexo博客加上文章分析 | Uncle_drew (cndrew.cn) 花里胡哨的Hexo | 给你的hexo博客加上仿GIthub文章日历以及分类雷达图 | Uncle_drew (cndrew.cn) hexo文章标签统计实现 添加说说参考： Hexo添加可实时发布的说说界面 | Artitalk.js | Uncle_drew (cndrew.cn) Hexo添加可实时发布的说说界面 | Artitalk.js | Uncle_drew (cndrew.cn) 为你的hexo博客添加动态的（可直接发布说说的）说说页面 | Uncle_drew (cndrew.cn) 添加评论系统本博客使用twikoo评论系统，采用Vercel部署。 参考： Twikoo 文档 添加随机文章的插件参考： 现已更新自动实现随机文章（插件）| Hexo实现随机文章 （暴力实现） | Uncle_drew (cndrew.cn) hexo-generator-random | Hexo插件 | Uncle_drew (cndrew.cn) GitHub - Drew233/hexo-generator-random 添加久远文章的提示参考： Javascript实现Hexo中给时间久远的文章增加友好的提示 | Uncle_drew (cndrew.cn) 参考2021年最全搭建+美化+使用博客教程 | Recluse (reclusew.github.io) 参考博客样式：Uncle_drew (cndrew.cn) BOHC! (hewanyue.com) wallleap 樱花庄的白猫 | ねこ・しろ・ましろ 冬天的雨滴 Tianyu Cui’s Blog","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"博客美化","slug":"博客美化","permalink":"/tags/博客美化/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}